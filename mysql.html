<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module mysql</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module mysql</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>MySQL client.


<h2><a name="description">Description</a></h2><p>MySQL client.</p>
 
  The <code>connection()</code> type is a gen_server reference as described in the
  documentation for <code>gen_server:call/2,3</code>, e.g. the pid or the name if the
  gen_server is locally registered.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-column_names">column_names()</a></h3>
<p><tt>column_names() = [binary()]</tt></p>


<h3 class="typedecl"><a name="type-connection">connection()</a></h3>
<p><tt>connection() = atom() | {Name::atom(), Node::atom()} | {global, GlobalName::term()} | {via, Module::atom(), ViaName::term()} | pid()</tt></p>


<h3 class="typedecl"><a name="type-query_result">query_result()</a></h3>
<p><tt>query_result() = ok | {ok, <a href="#type-column_names">column_names()</a>, <a href="#type-rows">rows()</a>} | {ok, [{<a href="#type-column_names">column_names()</a>, <a href="#type-rows">rows()</a>}, ...]} | {error, <a href="#type-server_reason">server_reason()</a>}</tt></p>


<h3 class="typedecl"><a name="type-rows">rows()</a></h3>
<p><tt>rows() = [[term()]]</tt></p>


<h3 class="typedecl"><a name="type-server_reason">server_reason()</a></h3>
<p><tt>server_reason() = {Code::integer(), SQLState::binary() | undefined, Message::binary()}</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#affected_rows-1">affected_rows/1</a></td><td>Returns the number of inserted, updated and deleted rows of the last
  executed query or prepared statement.</td></tr>
<tr><td valign="top"><a href="#autocommit-1">autocommit/1</a></td><td>Returns true if auto-commit is enabled and false otherwise.</td></tr>
<tr><td valign="top"><a href="#encode-2">encode/2</a></td><td>Encodes a term as a MySQL literal so that it can be used to inside a  
query.</td></tr>
<tr><td valign="top"><a href="#execute-3">execute/3</a></td><td>Executes a prepared statement with the default query timeout as given
  to start_link/1.</td></tr>
<tr><td valign="top"><a href="#execute-4">execute/4</a></td><td>Executes a prepared statement.</td></tr>
<tr><td valign="top"><a href="#in_transaction-1">in_transaction/1</a></td><td>Returns true if the connection is in a transaction and false otherwise.</td></tr>
<tr><td valign="top"><a href="#insert_id-1">insert_id/1</a></td><td>Returns the last insert-id.</td></tr>
<tr><td valign="top"><a href="#prepare-2">prepare/2</a></td><td>Creates a prepared statement from the passed query.</td></tr>
<tr><td valign="top"><a href="#prepare-3">prepare/3</a></td><td>Creates a prepared statement from the passed query and associates it
  with the given name.</td></tr>
<tr><td valign="top"><a href="#query-2">query/2</a></td><td>Executes a query with the query timeout as given to start_link/1.</td></tr>
<tr><td valign="top"><a href="#query-3">query/3</a></td><td>Depending on the 3rd argument this function does different things.</td></tr>
<tr><td valign="top"><a href="#query-4">query/4</a></td><td>Executes a parameterized query with a timeout.</td></tr>
<tr><td valign="top"><a href="#start_link-1">start_link/1</a></td><td>Starts a connection gen_server process and connects to a database.</td></tr>
<tr><td valign="top"><a href="#transaction-2">transaction/2</a></td><td>This function executes the functional object Fun as a transaction.</td></tr>
<tr><td valign="top"><a href="#transaction-3">transaction/3</a></td><td>This function executes the functional object Fun as a transaction.</td></tr>
<tr><td valign="top"><a href="#transaction-4">transaction/4</a></td><td>This function executes the functional object Fun with arguments Args as  
a transaction.</td></tr>
<tr><td valign="top"><a href="#unprepare-2">unprepare/2</a></td><td>Deallocates a prepared statement.</td></tr>
<tr><td valign="top"><a href="#warning_count-1">warning_count/1</a></td><td>Returns the number of warnings generated by the last query/2 or
  execute/3 calls.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="affected_rows-1">affected_rows/1</a></h3>
<div class="spec">
<p><tt>affected_rows(Conn::<a href="#type-connection">connection()</a>) -&gt; integer()</tt><br></p>
</div><p>Returns the number of inserted, updated and deleted rows of the last
  executed query or prepared statement. If found_rows is set on the
  connection, for update operation the return value will equal to the number
  of rows matched by the query.</p>

<h3 class="function"><a name="autocommit-1">autocommit/1</a></h3>
<div class="spec">
<p><tt>autocommit(Conn::<a href="#type-connection">connection()</a>) -&gt; boolean()</tt><br></p>
</div><p>Returns true if auto-commit is enabled and false otherwise.</p>

<h3 class="function"><a name="encode-2">encode/2</a></h3>
<div class="spec">
<p><tt>encode(Conn::<a href="#type-connection">connection()</a>, Term::term()) -&gt; iodata()</tt><br></p>
</div><p><p>Encodes a term as a MySQL literal so that it can be used to inside a  
query. If backslash escapes are enabled, backslashes and single quotes in  
strings and binaries are escaped. Otherwise only single quotes are escaped.</p>
 
  Note that the preferred way of sending values is by prepared statements or
  parametrized queries with placeholders.
 </p>
<p><b>See also:</b> <a href="#execute-3">execute/3</a>, <a href="#query-3">query/3</a>.</p>

<h3 class="function"><a name="execute-3">execute/3</a></h3>
<div class="spec">
<p><tt>execute(Conn, StatementRef, Params) -&gt; Result | {error, not_prepared}</tt>
<ul class="definitions"><li><tt>Conn = <a href="#type-connection">connection()</a></tt></li><li><tt>StatementRef = atom() | integer()</tt></li><li><tt>Params = [term()]</tt></li><li><tt>Result = <a href="#type-query_result">query_result()</a></tt></li></ul></p>
</div><p>Executes a prepared statement with the default query timeout as given
  to start_link/1.</p>
<p><b>See also:</b> <a href="#prepare-2">prepare/2</a>, <a href="#prepare-3">prepare/3</a>.</p>

<h3 class="function"><a name="execute-4">execute/4</a></h3>
<div class="spec">
<p><tt>execute(Conn, StatementRef, Params, Timeout) -&gt; Result | {error, not_prepared}</tt>
<ul class="definitions"><li><tt>Conn = <a href="#type-connection">connection()</a></tt></li><li><tt>StatementRef = atom() | integer()</tt></li><li><tt>Params = [term()]</tt></li><li><tt>Timeout = timeout()</tt></li><li><tt>Result = <a href="#type-query_result">query_result()</a></tt></li></ul></p>
</div><p>Executes a prepared statement.</p>
<p><b>See also:</b> <a href="#prepare-2">prepare/2</a>, <a href="#prepare-3">prepare/3</a>.</p>

<h3 class="function"><a name="in_transaction-1">in_transaction/1</a></h3>
<div class="spec">
<p><tt>in_transaction(Conn::<a href="#type-connection">connection()</a>) -&gt; boolean()</tt><br></p>
</div><p>Returns true if the connection is in a transaction and false otherwise.
  This works regardless of whether the transaction has been started using
  transaction/2,3 or using a plain <code>mysql:query(Connection, "BEGIN")</code>.</p>
<p><b>See also:</b> <a href="#transaction-2">transaction/2</a>, <a href="#transaction-4">transaction/4</a>.</p>

<h3 class="function"><a name="insert_id-1">insert_id/1</a></h3>
<div class="spec">
<p><tt>insert_id(Conn::<a href="#type-connection">connection()</a>) -&gt; integer()</tt><br></p>
</div><p>Returns the last insert-id.</p>

<h3 class="function"><a name="prepare-2">prepare/2</a></h3>
<div class="spec">
<p><tt>prepare(Conn, Query) -&gt; {ok, StatementId} | {error, Reason}</tt>
<ul class="definitions"><li><tt>Conn = <a href="#type-connection">connection()</a></tt></li><li><tt>Query = iodata()</tt></li><li><tt>StatementId = integer()</tt></li><li><tt>Reason = <a href="#type-server_reason">server_reason()</a></tt></li></ul></p>
</div><p>Creates a prepared statement from the passed query.</p>
<p><b>See also:</b> <a href="#prepare-3">prepare/3</a>.</p>

<h3 class="function"><a name="prepare-3">prepare/3</a></h3>
<div class="spec">
<p><tt>prepare(Conn, Name, Query) -&gt; {ok, Name} | {error, Reason}</tt>
<ul class="definitions"><li><tt>Conn = <a href="#type-connection">connection()</a></tt></li><li><tt>Name = atom()</tt></li><li><tt>Query = iodata()</tt></li><li><tt>Reason = <a href="#type-server_reason">server_reason()</a></tt></li></ul></p>
</div><p>Creates a prepared statement from the passed query and associates it
  with the given name.</p>
<p><b>See also:</b> <a href="#prepare-2">prepare/2</a>.</p>

<h3 class="function"><a name="query-2">query/2</a></h3>
<div class="spec">
<p><tt>query(Conn, Query) -&gt; Result</tt>
<ul class="definitions"><li><tt>Conn = <a href="#type-connection">connection()</a></tt></li><li><tt>Query = iodata()</tt></li><li><tt>Result = <a href="#type-query_result">query_result()</a></tt></li></ul></p>
</div><p><p>Executes a query with the query timeout as given to start_link/1.</p>
 
  <p>It is possible to execute multiple semicolon-separated queries.</p>
 
  <p>Results are returned in the form <code>{ok, ColumnNames, Rows}</code> if there is one
  result set. If there are more than one result sets, they are returned in the
  form <code>{ok, [{ColumnNames, Rows}, ...]}</code>.</p>
 
  For queries that don't return any rows (INSERT, UPDATE, etc.) only the atom
  <code>ok</code> is returned.</p>

<h3 class="function"><a name="query-3">query/3</a></h3>
<div class="spec">
<p><tt>query(Conn, Query, Params::Params | Timeout) -&gt; Result</tt>
<ul class="definitions"><li><tt>Conn = <a href="#type-connection">connection()</a></tt></li><li><tt>Query = iodata()</tt></li><li><tt>Timeout = timeout()</tt></li><li><tt>Params = [term()]</tt></li><li><tt>Result = <a href="#type-query_result">query_result()</a></tt></li></ul></p>
</div><p><p>Depending on the 3rd argument this function does different things.</p>
 
  <p>If the 3rd argument is a list, it executes a parameterized query. This is  
equivallent to query/4 with the query timeout as given to start_link/1.</p>
 
  <p>If the 3rd argument is a timeout, it executes a plain query with this  
timeout.</p>
 
  The return value is the same as for query/2.
 </p>
<p><b>See also:</b> <a href="#query-2">query/2</a>, <a href="#query-4">query/4</a>.</p>

<h3 class="function"><a name="query-4">query/4</a></h3>
<div class="spec">
<p><tt>query(Conn, Query, Params, Timeout) -&gt; Result</tt>
<ul class="definitions"><li><tt>Conn = <a href="#type-connection">connection()</a></tt></li><li><tt>Query = iodata()</tt></li><li><tt>Timeout = timeout()</tt></li><li><tt>Params = [term()]</tt></li><li><tt>Result = <a href="#type-query_result">query_result()</a></tt></li></ul></p>
</div><p><p>Executes a parameterized query with a timeout.</p>
 
  <p>A prepared statement is created, executed and then cached for a certain  
time. If the same query is executed again when it is already cached, it does  
not need to be prepared again.</p>
 
  <p>The minimum time the prepared statement is cached can be specified using the
  option <code>{query_cache_time, Milliseconds}</code> to start_link/1.</p>
 
  The return value is the same as for query/2.</p>

<h3 class="function"><a name="start_link-1">start_link/1</a></h3>
<div class="spec">
<p><tt>start_link(Options) -&gt; {ok, pid()} | ignore | {error, term()}</tt>
<ul class="definitions"><li><tt>Options = [Option]</tt></li><li><tt>Option = {name, ServerName} | {host, <a href="inet.html#type-socket_address">inet:socket_address()</a> | <a href="inet.html#type-hostname">inet:hostname()</a>} | {port, integer()} | {user, iodata()} | {password, iodata()} | {database, iodata()} | {connect_timeout, timeout()} | {log_warnings, boolean()} | {keep_alive, boolean() | timeout()} | {prepare, NamedStatements} | {queries, [iodata()]} | {query_timeout, timeout()} | {found_rows, boolean()} | {query_cache_time, non_neg_integer()}</tt></li><li><tt>ServerName = {local, Name::atom()} | {global, GlobalName::term()} | {via, Module::atom(), ViaName::term()}</tt></li><li><tt>NamedStatements = [{StatementName::atom(), Statement::iodata()}]</tt></li></ul></p>
</div><p><p>Starts a connection gen_server process and connects to a database. To
  disconnect just do <code>exit(Pid, normal)</code>.</p>
 
  <p>Options:</p>
 
  <dl>
    <dt><code>{name, ServerName}</code></dt>
    <dd>If a name is provided, the gen_server will be registered with this
        name. For details see the documentation for the first argument of
        gen_server:start_link/4.</dd>
    <dt><code>{host, Host}</code></dt>
    <dd>Hostname of the MySQL database; default <code>"localhost"</code>.</dd>
    <dt><code>{port, Port}</code></dt>
    <dd>Port; default 3306 if omitted.</dd>
    <dt><code>{user, User}</code></dt>
    <dd>Username.</dd>
    <dt><code>{password, Password}</code></dt>
    <dd>Password.</dd>
    <dt><code>{database, Database}</code></dt>
    <dd>The name of the database AKA schema to use. This can be changed later
        using the query <code>USE &lt;database&gt;</code>.</dd>
    <dt><code>{connect_timeout, Timeout}</code></dt>
    <dd>The maximum time to spend for start_link/1.</dd>
    <dt><code>{log_warnings, boolean()}</code></dt>
    <dd>Whether to fetch warnings and log them using error_logger; default
        true.</dd>
    <dt><code>{keep_alive, boolean() | timeout()}</code></dt>
    <dd>Send ping when unused for a certain time. Possible values are <code>true</code>,
        <code>false</code> and <code>integer() &gt; 0</code> for an explicit interval in milliseconds.
        The default is <code>false</code>. For <code>true</code> a default ping timeout is used.
        </dd>
    <dt><code>{prepare, NamedStatements}</code></dt>
    <dd>Named prepared statements to be created as soon as the connection is
        ready.</dd>
    <dt><code>{queries, Queries}</code></dt>
    <dd>Queries to be executed as soon as the connection is ready. Any results
        are discarded. Typically, this is used for setting time zone and other
        session variables.</dd>
    <dt><code>{query_timeout, Timeout}</code></dt>
    <dd>The default time to wait for a response when executing a query or a
        prepared statement. This can be given per query using <code>query/3,4</code> and
        <code>execute/4</code>. The default is <code>infinity</code>.</dd>
    <dt><code>{found_rows, boolean()}</code></dt>
    <dd>If set to true, the connection will be established with
        CLIENT_FOUND_ROWS capability. affected_rows/1 will now return the
        number of found rows, not the number of rows changed by the
        query.</dd>
    <dt><code>{query_cache_time, Timeout}</code></dt>
    <dd>The minimum number of milliseconds to cache prepared statements used
        for parametrized queries with query/3.</dd>
    <dt><code>{tcp_options, Options}</code></dt>
    <dd>Additional options for <code>gen_tcp:connect/3</code>. You may want to set
        <code>{recbuf, Size}</code> and <code>{sndbuf, Size}</code> if you send or receive more than
        the default (typically 8K) per query.</dd>
  </dl></p>

<h3 class="function"><a name="transaction-2">transaction/2</a></h3>
<div class="spec">
<p><tt>transaction(Conn::<a href="#type-connection">connection()</a>, Fun::function()) -&gt; {atomic, term()} | {aborted, term()}</tt><br></p>
</div><p>This function executes the functional object Fun as a transaction.</p>
<p><b>See also:</b> <a href="#transaction-4">transaction/4</a>.</p>

<h3 class="function"><a name="transaction-3">transaction/3</a></h3>
<div class="spec">
<p><tt>transaction(Conn::<a href="#type-connection">connection()</a>, Fun::function(), Retries) -&gt; {atomic, term()} | {aborted, term()}</tt>
<ul class="definitions"><li><tt>Retries = non_neg_integer() | infinity</tt></li></ul></p>
</div><p>This function executes the functional object Fun as a transaction.</p>
<p><b>See also:</b> <a href="#transaction-4">transaction/4</a>.</p>

<h3 class="function"><a name="transaction-4">transaction/4</a></h3>
<div class="spec">
<p><tt>transaction(Conn::<a href="#type-connection">connection()</a>, Fun::function(), Args::list(), Retries) -&gt; {atomic, term()} | {aborted, term()}</tt>
<ul class="definitions"><li><tt>Retries = non_neg_integer() | infinity</tt></li></ul></p>
</div><p><p>This function executes the functional object Fun with arguments Args as  
a transaction.</p>
 
  <p>The semantics are as close as possible to mnesia's transactions. Transactions  
can be nested and are restarted automatically when deadlocks are detected.  
MySQL's savepoints are used to implement nested transactions.</p>
 
  <p>Fun must be a function and Args must be a list of the same length as the  
arity of Fun.</p>
 
  <p>If an exception occurs within Fun, the exception is caught and <code>{aborted,
  Reason}</code> is returned. The value of <code>Reason</code> depends on the class of the  
exception.</p>
 
  <p>Note that an error response from a query does not cause a transaction to be
  rollbacked. To force a rollback on a MySQL error you can trigger a <code>badmatch</code>
  using e.g. <code>ok = mysql:query(Pid, "SELECT some_non_existent_value")</code>. An  
exception to this is the error 1213 "Deadlock", after the specified number  
of retries, all failed. In this case, the transaction is aborted and the  
error is retured as the reason for the aborted transaction, along with a  
stacktrace pointing to where the last deadlock was detected. (In earlier  
versions, up to and including 1.3.2, transactions where automatically  
restarted also for the error 1205 "Lock wait timeout". This is no longer the  
case.)</p>
 
  <p>Some queries such as ALTER TABLE cause an *implicit commit* on the server.
  If such a query is executed within a transaction, an error on the form
  <code>{implicit_commit, Query}</code> is raised. This means that the transaction has  
been committed prematurely. This also happens if an explicit COMMIT is  
executed as a plain query within a managed transaction. (Don't do that!)</p>
 
  <table>
    <thead>
      <tr><th>Class of exception</th><th>Return value</th></tr>
    </thead>
    <tbody>
      <tr>
        <td><code>error</code> with reason <code>ErrorReason</code></td>
        <td><code>{aborted, {ErrorReason, Stack}}</code></td>
      </tr>
      <tr><td><code>exit(Term)</code></td><td><code>{aborted, Term}</code></td></tr>
      <tr><td><code>throw(Term)</code></td><td><code>{aborted, {throw, Term}}</code></td></tr>
    </tbody>
  </table></p>

<h3 class="function"><a name="unprepare-2">unprepare/2</a></h3>
<div class="spec">
<p><tt>unprepare(Conn, StatementRef) -&gt; ok | {error, Reason}</tt>
<ul class="definitions"><li><tt>Conn = <a href="#type-connection">connection()</a></tt></li><li><tt>StatementRef = atom() | integer()</tt></li><li><tt>Reason = <a href="#type-server_reason">server_reason()</a> | not_prepared</tt></li></ul></p>
</div><p>Deallocates a prepared statement.</p>

<h3 class="function"><a name="warning_count-1">warning_count/1</a></h3>
<div class="spec">
<p><tt>warning_count(Conn::<a href="#type-connection">connection()</a>) -&gt; integer()</tt><br></p>
</div><p>Returns the number of warnings generated by the last query/2 or
  execute/3 calls.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
