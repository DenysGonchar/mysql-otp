<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>cover/mysql_protocol.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/viktor/data/mysql-otp/ebin/../src/mysql_protocol.erl by COVER 2018-12-02 at 22:43:59

****************************************************************************

        |  %% MySQL/OTP – MySQL client library for Erlang/OTP
        |  %% Copyright (C) 2014 Viktor Söderqvist
        |  %%               2017 Piotr Nosek, Michal Slaski
        |  %%
        |  %% This file is part of MySQL/OTP.
        |  %%
        |  %% MySQL/OTP is free software: you can redistribute it and/or modify it under
        |  %% the terms of the GNU Lesser General Public License as published by the Free
        |  %% Software Foundation, either version 3 of the License, or (at your option)
        |  %% any later version.
        |  %%
        |  %% This program is distributed in the hope that it will be useful, but WITHOUT
        |  %% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
        |  %% FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
        |  %% more details.
        |  %%
        |  %% You should have received a copy of the GNU Lesser General Public License
        |  %% along with this program. If not, see &lt;https://www.gnu.org/licenses/&gt;.
        |  
        |  %% @doc This module implements parts of the MySQL client/server protocol.
        |  %%
        |  %% The protocol is described in the document "MySQL Internals" which can be
        |  %% found under "MySQL Documentation: Expert Guides" on http://dev.mysql.com/.
        |  %%
        |  %% TCP communication is not handled in this module. Most of the public functions
        |  %% take funs for data communitaction as parameters.
        |  %% @private
        |  -module(mysql_protocol).
        |  
        |  -export([handshake/7, quit/2, ping/2,
        |           query/4, fetch_query_response/3,
        |           prepare/3, unprepare/3, execute/5, fetch_execute_response/3]).
        |  
        |  %% How much data do we want per packet?
        |  -define(MAX_BYTES_PER_PACKET, 16#1000000).
        |  
        |  -include("records.hrl").
        |  -include("protocol.hrl").
        |  -include("server_status.hrl").
        |  
        |  %% Macros for pattern matching on packets.
        |  -define(ok_pattern, &lt;&lt;?OK, _/binary&gt;&gt;).
        |  -define(error_pattern, &lt;&lt;?ERROR, _/binary&gt;&gt;).
        |  -define(eof_pattern, &lt;&lt;?EOF, _:4/binary&gt;&gt;).
        |  
        |  %% @doc Performs a handshake using the supplied functions for communication.
        |  %% Returns an ok or an error record. Raises errors when various unimplemented
        |  %% features are requested.
        |  -spec handshake(Username :: iodata(), Password :: iodata(),
        |                  Database :: iodata() | undefined,
        |                  SockModule :: module(), SSLOpts :: list() | undefined,
        |                  Socket :: term(),
        |                  SetFoundRows :: boolean()) -&gt;
        |      {ok, #handshake{}, SockModule :: module(), Socket :: term()} |
        |      #error{}.
        |  handshake(Username, Password, Database, SockModule0, SSLOpts, Socket0,
        |            SetFoundRows) -&gt;
    23..|      SeqNum0 = 0,
    23..|      {ok, HandshakePacket, SeqNum1} = recv_packet(SockModule0, Socket0, SeqNum0),
    23..|      case parse_handshake(HandshakePacket) of
        |          #handshake{} = Handshake -&gt;
    21..|              {ok, SockModule, Socket, SeqNum2} =
        |                  maybe_do_ssl_upgrade(SockModule0, Socket0, SeqNum1, Handshake,
        |                                       SSLOpts, Database, SetFoundRows),
    21..|              Response = build_handshake_response(Handshake, Username, Password,
        |                                                  Database, SetFoundRows),
    21..|              {ok, SeqNum3} = send_packet(SockModule, Socket, Response, SeqNum2),
    21..|              handshake_finish_or_switch_auth(Handshake, Password, SockModule,
        |                                              Socket, SeqNum3);
        |          #error{} = Error -&gt;
     1..|              Error
        |      end.
        |  
        |  handshake_finish_or_switch_auth(Handshake = #handshake{status = Status}, Password,
        |                                  SockModule, Socket, SeqNum0) -&gt;
    21..|      {ok, ConfirmPacket, SeqNum1} = recv_packet(SockModule, Socket, SeqNum0),
    21..|      case parse_handshake_confirm(ConfirmPacket) of
        |          #ok{status = OkStatus} -&gt;
        |              %% check status, ignoring bit 16#4000, SERVER_SESSION_STATE_CHANGED.
    20..|              Status = OkStatus band bnot 16#4000,
    20..|              {ok, Handshake, SockModule, Socket};
        |          #auth_method_switch{auth_plugin_name = AuthPluginName,
        |                              auth_plugin_data = AuthPluginData} -&gt;
<font color=red>     0..|              Hash = case AuthPluginName of</font>
        |                         &lt;&lt;&gt;&gt; -&gt;
<font color=red>     0..|                             hash_password(Password, AuthPluginData);</font>
        |                         &lt;&lt;"mysql_native_password"&gt;&gt; -&gt;
<font color=red>     0..|                             hash_password(Password, AuthPluginData);</font>
        |                         UnknownAuthMethod -&gt;
<font color=red>     0..|                             error({auth_method, UnknownAuthMethod})</font>
        |                     end,
<font color=red>     0..|              {ok, SeqNum2} = send_packet(SockModule, Socket, Hash, SeqNum1),</font>
<font color=red>     0..|              handshake_finish_or_switch_auth(Handshake, Password, SockModule,</font>
        |                                              Socket, SeqNum2);
        |          Error -&gt;
     1..|              Error
        |      end.
        |  
        |  -spec quit(atom(), term()) -&gt; ok.
        |  quit(SockModule, Socket) -&gt;
    16..|      {ok, SeqNum1} = send_packet(SockModule, Socket, &lt;&lt;?COM_QUIT&gt;&gt;, 0),
    16..|      case recv_packet(SockModule, Socket, SeqNum1) of
    16..|          {error, closed} -&gt; ok;            %% MySQL 5.5.40 and more
<font color=red>     0..|          {ok, ?ok_pattern, _SeqNum2} -&gt; ok %% Some older MySQL versions?</font>
        |      end.
        |  
        |  -spec ping(atom(), term()) -&gt; #ok{}.
        |  ping(SockModule, Socket) -&gt;
     4..|      {ok, SeqNum1} = send_packet(SockModule, Socket, &lt;&lt;?COM_PING&gt;&gt;, 0),
     3..|      {ok, OkPacket, _SeqNum2} = recv_packet(SockModule, Socket, SeqNum1),
     3..|      parse_ok_packet(OkPacket).
        |  
        |  -spec query(Query :: iodata(), atom(), term(), timeout()) -&gt;
        |      {ok, [#ok{} | #resultset{} | #error{}]} | {error, timeout}.
        |  query(Query, SockModule, Socket, Timeout) -&gt;
   453..|      Req = &lt;&lt;?COM_QUERY, (iolist_to_binary(Query))/binary&gt;&gt;,
   453..|      SeqNum0 = 0,
   453..|      {ok, _SeqNum1} = send_packet(SockModule, Socket, Req, SeqNum0),
   453..|      fetch_query_response(SockModule, Socket, Timeout).
        |  
        |  %% @doc This is used by query/4. If query/4 returns {error, timeout}, this
        |  %% function can be called to retry to fetch the results of the query.
        |  fetch_query_response(SockModule, Socket, Timeout) -&gt;
   454..|      fetch_response(SockModule, Socket, Timeout, text, []).
        |  
        |  %% @doc Prepares a statement.
        |  -spec prepare(iodata(), atom(), term()) -&gt; #error{} | #prepared{}.
        |  prepare(Query, SockModule, Socket) -&gt;
   110..|      Req = &lt;&lt;?COM_STMT_PREPARE, (iolist_to_binary(Query))/binary&gt;&gt;,
   110..|      {ok, SeqNum1} = send_packet(SockModule, Socket, Req, 0),
   110..|      {ok, Resp, SeqNum2} = recv_packet(SockModule, Socket, SeqNum1),
   110..|      case Resp of
        |          ?error_pattern -&gt;
     3..|              parse_error_packet(Resp);
        |          &lt;&lt;?OK,
        |            StmtId:32/little,
        |            NumColumns:16/little,
        |            NumParams:16/little,
        |            0, %% reserved_1 -- [00] filler
        |            WarningCount:16/little&gt;&gt; -&gt;
        |              %% This was the first packet.
        |              %% Now: Parameter Definition Block. The parameter definitions don't
        |              %% contain any useful data at all. They are always TYPE_VAR_STRING
        |              %% with charset 'binary' so we have to select a type ourselves for
        |              %% the parameters we have in execute/4.
   107..|              {_ParamDefs, SeqNum3} =
        |                  fetch_column_definitions_if_any(NumParams, SockModule, Socket,
        |                                                  SeqNum2),
        |              %% Column Definition Block. We get column definitions in execute
        |              %% too, so we don't need them here. We *could* store them to be able
        |              %% to provide the user with some info about a prepared statement.
   107..|              {_ColDefs, _SeqNum4} =
        |                  fetch_column_definitions_if_any(NumColumns, SockModule, Socket,
        |                                                  SeqNum3),
   107..|              #prepared{statement_id = StmtId,
        |                        orig_query = Query,
        |                        param_count = NumParams,
        |                        warning_count = WarningCount}
        |      end.
        |  
        |  %% @doc Deallocates a prepared statement.
        |  -spec unprepare(#prepared{}, atom(), term()) -&gt; ok.
        |  unprepare(#prepared{statement_id = Id}, SockModule, Socket) -&gt;
    90..|      {ok, _SeqNum} = send_packet(SockModule, Socket,
        |                                  &lt;&lt;?COM_STMT_CLOSE, Id:32/little&gt;&gt;, 0),
    90..|      ok.
        |  
        |  %% @doc Executes a prepared statement.
        |  -spec execute(#prepared{}, [term()], atom(), term(), timeout()) -&gt;
        |      {ok, [#ok{} | #resultset{} | #error{}]} | {error, timeout}.
        |  execute(#prepared{statement_id = Id, param_count = ParamCount}, ParamValues,
        |          SockModule, Socket, Timeout) when ParamCount == length(ParamValues) -&gt;
        |      %% Flags Constant Name
        |      %% 0x00 CURSOR_TYPE_NO_CURSOR
        |      %% 0x01 CURSOR_TYPE_READ_ONLY
        |      %% 0x02 CURSOR_TYPE_FOR_UPDATE
        |      %% 0x04 CURSOR_TYPE_SCROLLABLE
   192..|      Flags = 0,
   192..|      Req0 = &lt;&lt;?COM_STMT_EXECUTE, Id:32/little, Flags, 1:32/little&gt;&gt;,
   192..|      Req = case ParamCount of
        |          0 -&gt;
   111..|              Req0;
        |          _ -&gt;
        |              %% We can't use the parameter types returned by the prepare call.
        |              %% They are all reported as ?TYPE_VAR_STRING with character
        |              %% set 'binary'.
    81..|              NullBitMap = build_null_bitmap(ParamValues),
        |              %% What does it mean to *not* bind new params? To use the same
        |              %% params as last time? Right now we always bind params each time.
    81..|              NewParamsBoundFlag = 1,
    81..|              Req1 = &lt;&lt;Req0/binary, NullBitMap/binary, NewParamsBoundFlag&gt;&gt;,
        |              %% For each value, first append type and signedness (16#80 signed or
        |              %% 00 unsigned) for all values and then the binary encoded values.
    81..|              EncodedParams = lists:map(fun encode_param/1, ParamValues),
    81..|              {TypesAndSigns, EncValues} = lists:unzip(EncodedParams),
    81..|              iolist_to_binary([Req1, TypesAndSigns, EncValues])
        |      end,
   192..|      {ok, _SeqNum1} = send_packet(SockModule, Socket, Req, 0),
   192..|      fetch_execute_response(SockModule, Socket, Timeout).
        |  
        |  %% @doc This is used by execute/5. If execute/5 returns {error, timeout}, this
        |  %% function can be called to retry to fetch the results of the query.
        |  fetch_execute_response(SockModule, Socket, Timeout) -&gt;
   194..|      fetch_response(SockModule, Socket, Timeout, binary, []).
        |  
        |  %% --- internal ---
        |  
        |  %% @doc Parses a handshake. This is the first thing that comes from the server
        |  %% when connecting. If an unsupported version or variant of the protocol is used
        |  %% an error is raised.
        |  -spec parse_handshake(binary()) -&gt; #handshake{} | #error{}.
        |  parse_handshake(&lt;&lt;10, Rest/binary&gt;&gt;) -&gt;
        |      %% Protocol version 10.
    21..|      {ServerVersion, Rest1} = nulterm_str(Rest),
        |      &lt;&lt;ConnectionId:32/little,
        |        AuthPluginDataPart1:8/binary-unit:8,
        |        0, %% "filler" -- everything below is optional
        |        CapabilitiesLower:16/little,
        |        CharacterSet:8,
        |        StatusFlags:16/little,
        |        CapabilitiesUpper:16/little,
        |        AuthPluginDataLength:8,     %% if cabab &amp; CLIENT_PLUGIN_AUTH, otherwise 0
        |        _Reserved:10/binary-unit:8, %% 10 unused (reserved) bytes
    21..|        Rest3/binary&gt;&gt; = Rest1,
    21..|      Capabilities = CapabilitiesLower + 16#10000 * CapabilitiesUpper,
    21..|      Len = case AuthPluginDataLength of
<font color=red>     0..|          0 -&gt; 13;   %% Server has not CLIENT_PLUGIN_AUTH</font>
    21..|          K -&gt; K - 8 %% Part 2 length = Total length minus the 8 bytes in part 1.
        |      end,
    21..|      &lt;&lt;AuthPluginDataPart2:Len/binary-unit:8, AuthPluginName/binary&gt;&gt; = Rest3,
    21..|      AuthPluginData = &lt;&lt;AuthPluginDataPart1/binary, AuthPluginDataPart2/binary&gt;&gt;,
        |      %% "Due to Bug#59453 the auth-plugin-name is missing the terminating
        |      %% NUL-char in versions prior to 5.5.10 and 5.6.2."
        |      %% Strip the final NUL byte if any.
        |      %% This may also be &lt;&lt;&gt;&gt; in older versions.
    21..|      L = byte_size(AuthPluginName) - 1,
    21..|      AuthPluginName1 = case AuthPluginName of
    21..|          &lt;&lt;AuthPluginNameTrimmed:L/binary, 0&gt;&gt; -&gt; AuthPluginNameTrimmed;
<font color=red>     0..|          _ -&gt; AuthPluginName</font>
        |      end,
    21..|      #handshake{server_version = server_version_to_list(ServerVersion),
        |                 connection_id = ConnectionId,
        |                 capabilities = Capabilities,
        |                 character_set = CharacterSet,
        |                 status = StatusFlags,
        |                 auth_plugin_data = AuthPluginData,
        |                 auth_plugin_name = AuthPluginName1};
        |  parse_handshake(&lt;&lt;?ERROR, ErrNo:16/little, Msg/binary&gt;&gt;) -&gt;
        |      %% 'Too many connections' in MariaDB 10.1.21
        |      %% (Error packet in pre-4.1 protocol)
     1..|      #error{code = ErrNo, msg = Msg};
        |  parse_handshake(&lt;&lt;Protocol:8, _/binary&gt;&gt;) when Protocol /= 10 -&gt;
     1..|      error(unknown_protocol).
        |  
        |  %% @doc Converts a version on the form `&lt;&lt;"5.6.21"&gt;' to a list `[5, 6, 21]'.
        |  -spec server_version_to_list(binary()) -&gt; [integer()].
        |  server_version_to_list(ServerVersion) -&gt;
        |      %% This must work with e.g. "5.5.40-0ubuntu0.12.04.1-log" and "5.5.33a".
    21..|      {match, Parts} = re:run(ServerVersion, &lt;&lt;"^(\\d+)\\.(\\d+)\\.(\\d+)"&gt;&gt;,
        |                              [{capture, all_but_first, binary}]),
    21..|      lists:map(fun binary_to_integer/1, Parts).
        |  
        |  -spec maybe_do_ssl_upgrade(SockModule0 :: module(),
        |                             Socket0 :: term(),
        |                             SeqNum1 :: non_neg_integer(),
        |                             Handshake :: #handshake{},
        |                             SSLOpts :: undefined | list(),
        |                             Database :: iodata() | undefined,
        |                             SetFoundRows :: boolean()) -&gt;
        |      {ok, SockModule :: module(), Socket :: term(),
        |       SeqNum2 :: non_neg_integer()}.
        |  maybe_do_ssl_upgrade(SockModule0, Socket0, SeqNum1, _Handshake, undefined,
        |                       _Database, _SetFoundRows) -&gt;
    20..|      {ok, SockModule0, Socket0, SeqNum1};
        |  maybe_do_ssl_upgrade(SockModule0, Socket0, SeqNum1, Handshake, SSLOpts,
        |                       Database, SetFoundRows) -&gt;
     1..|      Response = build_handshake_response(Handshake, Database, SetFoundRows),
     1..|      {ok, SeqNum2} = send_packet(SockModule0, Socket0, Response, SeqNum1),
     1..|      case mysql_sock_ssl:connect(Socket0, SSLOpts, 5000) of
        |          {ok, SSLSocket} -&gt;
     1..|              {ok, ssl, SSLSocket, SeqNum2};
        |          {error, Reason} -&gt;
<font color=red>     0..|              exit({failed_to_upgrade_socket, Reason})</font>
        |      end.
        |  
        |  %% @doc This function is used when upgrading to encrypted socket. In other,
        |  %% cases, build_handshake_response/5 is used.
        |  -spec build_handshake_response(#handshake{}, iodata() | undefined, boolean()) -&gt;
        |      binary().
        |  build_handshake_response(Handshake, Database, SetFoundRows) -&gt;
     1..|      CapabilityFlags = basic_capabilities(Database /= undefined, SetFoundRows),
     1..|      verify_server_capabilities(Handshake, CapabilityFlags),
     1..|      ClientCapabilities = add_client_capabilities(CapabilityFlags),
     1..|      ClientSSLCapabilities = ClientCapabilities bor ?CLIENT_SSL,
     1..|      CharacterSet = ?UTF8,
     1..|      &lt;&lt;ClientSSLCapabilities:32/little,
        |        ?MAX_BYTES_PER_PACKET:32/little,
        |        CharacterSet:8,
        |        0:23/unit:8&gt;&gt;.
        |  
        |  %% @doc The response sent by the client to the server after receiving the
        |  %% initial handshake from the server
        |  -spec build_handshake_response(#handshake{}, iodata(), iodata(),
        |                                 iodata() | undefined, boolean()) -&gt; binary().
        |  build_handshake_response(Handshake, Username, Password, Database,
        |                           SetFoundRows) -&gt;
    21..|      CapabilityFlags = basic_capabilities(Database /= undefined, SetFoundRows),
    21..|      verify_server_capabilities(Handshake, CapabilityFlags),
        |      %% Add some extra capability flags only for signalling to the server what
        |      %% the client wants to do. The server doesn't say it handles them although
        |      %% it does. (http://bugs.mysql.com/bug.php?id=42268)
    21..|      ClientCapabilityFlags = add_client_capabilities(CapabilityFlags),
    21..|      Hash = case Handshake#handshake.auth_plugin_name of
        |          &lt;&lt;&gt;&gt; -&gt;
        |              %% Server doesn't know auth plugins
<font color=red>     0..|              hash_password(Password, Handshake#handshake.auth_plugin_data);</font>
        |          &lt;&lt;"mysql_native_password"&gt;&gt; -&gt;
    21..|              hash_password(Password, Handshake#handshake.auth_plugin_data);
        |          UnknownAuthMethod -&gt;
<font color=red>     0..|              error({auth_method, UnknownAuthMethod})</font>
        |      end,
    21..|      HashLength = size(Hash),
    21..|      CharacterSet = ?UTF8,
    21..|      UsernameUtf8 = unicode:characters_to_binary(Username),
    21..|      DbBin = case Database of
    20..|          undefined -&gt; &lt;&lt;&gt;&gt;;
     1..|          _         -&gt; &lt;&lt;(iolist_to_binary(Database))/binary, 0&gt;&gt;
        |      end,
    21..|      &lt;&lt;ClientCapabilityFlags:32/little,
        |        ?MAX_BYTES_PER_PACKET:32/little,
        |        CharacterSet:8,
        |        0:23/unit:8, %% reserverd
        |        UsernameUtf8/binary,
        |        0, %% NUL-terminator for the username
        |        HashLength,
        |        Hash/binary,
        |        DbBin/binary&gt;&gt;.
        |  
        |  -spec verify_server_capabilities(Handshake :: #handshake{},
        |                                   CapabilityFlags :: integer()) -&gt;
        |      true | no_return().
        |  verify_server_capabilities(Handshake, CapabilityFlags) -&gt;
        |      %% We require these capabilities. Make sure the server handles them.
    22..|      Handshake#handshake.capabilities band CapabilityFlags == CapabilityFlags
<font color=red>     0..|          orelse error(old_server_version).</font>
        |  
        |  -spec basic_capabilities(ConnectWithDB :: boolean(),
        |                           SetFoundRows :: boolean()) -&gt; integer().
        |  basic_capabilities(ConnectWithDB, SetFoundRows) -&gt;
    22..|      CapabilityFlags0 = ?CLIENT_PROTOCOL_41 bor
        |                         ?CLIENT_TRANSACTIONS bor
        |                         ?CLIENT_SECURE_CONNECTION,
    22..|      CapabilityFlags1 = case ConnectWithDB of
     1..|                             true -&gt; CapabilityFlags0 bor ?CLIENT_CONNECT_WITH_DB;
    21..|                             _ -&gt; CapabilityFlags0
        |                         end,
    22..|      case SetFoundRows of
     1..|          true -&gt; CapabilityFlags1 bor ?CLIENT_FOUND_ROWS;
    21..|          _    -&gt; CapabilityFlags1
        |      end.
        |  
        |  -spec add_client_capabilities(Caps :: integer()) -&gt; integer().
        |  add_client_capabilities(Caps) -&gt;
        |      Caps bor
        |      ?CLIENT_MULTI_STATEMENTS bor
    22..|      ?CLIENT_MULTI_RESULTS bor
        |      ?CLIENT_PS_MULTI_RESULTS.
        |  
        |  %% @doc Handles the second packet from the server, when we have replied to the
        |  %% initial handshake. Returns an error if the server returns an error. Raises
        |  %% an error if unimplemented features are required.
        |  -spec parse_handshake_confirm(binary()) -&gt; #ok{} | #auth_method_switch{} |
        |                                             #error{}.
        |  parse_handshake_confirm(Packet) -&gt;
    21..|      case Packet of
        |          ?ok_pattern -&gt;
        |              %% Connection complete.
    20..|              parse_ok_packet(Packet);
        |          ?error_pattern -&gt;
        |              %% Access denied, insufficient client capabilities, etc.
     1..|              parse_error_packet(Packet);
        |          &lt;&lt;?EOF&gt;&gt; -&gt;
        |              %% "Old Authentication Method Switch Request Packet consisting of a
        |              %% single 0xfe byte. It is sent by server to request client to
        |              %% switch to Old Password Authentication if CLIENT_PLUGIN_AUTH
        |              %% capability is not supported (by either the client or the server)"
<font color=red>     0..|              error(old_auth);</font>
        |          &lt;&lt;?EOF, AuthMethodSwitch/binary&gt;&gt; -&gt;
        |              %% "Authentication Method Switch Request Packet. If both server and
        |              %% client support CLIENT_PLUGIN_AUTH capability, server can send
        |              %% this packet to ask client to use another authentication method."
<font color=red>     0..|              parse_auth_method_switch(AuthMethodSwitch)</font>
        |      end.
        |  
        |  %% -- both text and binary protocol --
        |  
        |  %% @doc Fetches one or more results and and parses the result set(s) using
        |  %% either the text format (for plain queries) or the binary format (for
        |  %% prepared statements).
        |  -spec fetch_response(atom(), term(), timeout(), text | binary, list()) -&gt;
        |      {ok, [#ok{} | #resultset{} | #error{}]} | {error, timeout}.
        |  fetch_response(SockModule, Socket, Timeout, Proto, Acc) -&gt;
   656..|      case recv_packet(SockModule, Socket, Timeout, any) of
        |          {ok, Packet, SeqNum2} -&gt;
   653..|              Result = case Packet of
        |                  ?ok_pattern -&gt;
   393..|                      parse_ok_packet(Packet);
        |                  ?error_pattern -&gt;
     5..|                      parse_error_packet(Packet);
        |                  ResultPacket -&gt;
        |                      %% The first packet in a resultset is only the column count.
   255..|                      {ColCount, &lt;&lt;&gt;&gt;} = lenenc_int(ResultPacket),
   255..|                      R0 = fetch_resultset(SockModule, Socket, ColCount, SeqNum2),
   255..|                      case R0 of
        |                          #error{} = E -&gt;
        |                              %% TODO: Find a way to get here + testcase
     1..|                              E;
        |                          #resultset{} = R -&gt;
   254..|                              parse_resultset(R, ColCount, Proto)
        |                      end
        |              end,
   653..|              Acc1 = [Result | Acc],
   653..|              case more_results_exists(Result) of
        |                  true -&gt;
     8..|                      fetch_response(SockModule, Socket, Timeout, Proto, Acc1);
        |                  false -&gt;
   645..|                      {ok, lists:reverse(Acc1)}
        |              end;
        |          {error, timeout} -&gt;
     3..|              {error, timeout}
        |      end.
        |  
        |  %% @doc Fetches packets for a result set. The column definitions are parsed but
        |  %% the rows are unparsed binary packages. This function is used for both the
        |  %% text protocol and the binary protocol. This affects the way the rows need to
        |  %% be parsed.
        |  -spec fetch_resultset(atom(), term(), integer(), integer()) -&gt;
        |      #resultset{} | #error{}.
        |  fetch_resultset(SockModule, Socket, FieldCount, SeqNum) -&gt;
   255..|      {ok, ColDefs, SeqNum1} = fetch_column_definitions(SockModule, Socket,
        |                                                        SeqNum, FieldCount, []),
   255..|      {ok, DelimiterPacket, SeqNum2} = recv_packet(SockModule, Socket, SeqNum1),
   255..|      #eof{status = S, warning_count = W} = parse_eof_packet(DelimiterPacket),
   255..|      case fetch_resultset_rows(SockModule, Socket, SeqNum2, []) of
        |          {ok, Rows, _SeqNum3} -&gt;
   254..|              ColDefs1 = lists:map(fun parse_column_definition/1, ColDefs),
   254..|              #resultset{cols = ColDefs1, rows = Rows,
        |                         status = S, warning_count = W};
        |          #error{} = E -&gt;
     1..|              E
        |      end.
        |  
        |  parse_resultset(#resultset{cols = ColDefs, rows = Rows} = R, ColumnCount,
        |                  text) -&gt;
        |      %% Parse the rows according to the 'text protocol' representation.
   138..|      Rows1 = [decode_text_row(ColumnCount, ColDefs, Row) || Row &lt;- Rows],
   138..|      R#resultset{rows = Rows1};
        |  parse_resultset(#resultset{cols = ColDefs, rows = Rows} = R, ColumnCount,
        |                  binary) -&gt;
        |      %% Parse the rows according to the 'binary protocol' representation.
   116..|      Rows1 = [decode_binary_row(ColumnCount, ColDefs, Row) || Row &lt;- Rows],
   116..|      R#resultset{rows = Rows1}.
        |  
        |  more_results_exists(#ok{status = S}) -&gt;
   393..|      S band ?SERVER_MORE_RESULTS_EXISTS /= 0;
        |  more_results_exists(#error{}) -&gt;
     6..|      false; %% No status bits for error
        |  more_results_exists(#resultset{status = S}) -&gt;
   254..|      S band ?SERVER_MORE_RESULTS_EXISTS /= 0.
        |  
        |  %% @doc Receives NumLeft column definition packets. They are not parsed.
        |  %% @see parse_column_definition/1
        |  -spec fetch_column_definitions(atom(), term(), SeqNum :: integer(),
        |                                 NumLeft :: integer(), Acc :: [binary()]) -&gt;
        |      {ok, ColDefPackets :: [binary()], NextSeqNum :: integer()}.
        |  fetch_column_definitions(SockModule, Socket, SeqNum, NumLeft, Acc)
        |    when NumLeft &gt; 0 -&gt;
   426..|      {ok, Packet, SeqNum1} = recv_packet(SockModule, Socket, SeqNum),
   426..|      fetch_column_definitions(SockModule, Socket, SeqNum1, NumLeft - 1,
        |                               [Packet | Acc]);
        |  fetch_column_definitions(_SockModule, _Socket, SeqNum, 0, Acc) -&gt;
   368..|      {ok, lists:reverse(Acc), SeqNum}.
        |  
        |  %% @doc Fetches rows in a result set. There is a packet per row. The row packets
        |  %% are not decoded. This function can be used for both the binary and the text
        |  %% protocol result sets.
        |  -spec fetch_resultset_rows(atom(), term(), SeqNum :: integer(), Acc) -&gt;
        |      {ok, Rows, integer()} | #error{}
        |      when Acc :: [binary()],
        |           Rows :: [binary()].
        |  fetch_resultset_rows(SockModule, Socket, SeqNum, Acc) -&gt;
   505..|      {ok, Packet, SeqNum1} = recv_packet(SockModule, Socket, SeqNum),
   505..|      case Packet of
        |          ?error_pattern -&gt;
     1..|              parse_error_packet(Packet);
        |          ?eof_pattern -&gt;
   254..|              {ok, lists:reverse(Acc), SeqNum1};
        |          Row -&gt;
   250..|              fetch_resultset_rows(SockModule, Socket, SeqNum1, [Row | Acc])
        |      end.
        |  
        |  %% Parses a packet containing a column definition (part of a result set)
        |  parse_column_definition(Data) -&gt;
   281..|      {&lt;&lt;"def"&gt;&gt;, Rest1} = lenenc_str(Data),   %% catalog (always "def")
   281..|      {_Schema, Rest2} = lenenc_str(Rest1),    %% schema-name
   281..|      {_Table, Rest3} = lenenc_str(Rest2),     %% virtual table-name
   281..|      {_OrgTable, Rest4} = lenenc_str(Rest3),  %% physical table-name
   281..|      {Name, Rest5} = lenenc_str(Rest4),       %% virtual column name
   281..|      {_OrgName, Rest6} = lenenc_str(Rest5),   %% physical column name
   281..|      {16#0c, Rest7} = lenenc_int(Rest6),      %% length of the following fields
        |                                               %% (always 0x0c)
        |      &lt;&lt;Charset:16/little,        %% column character set
        |        Length:32/little,         %% maximum length of the field
        |        Type:8,                   %% type of the column as defined in Column Type
        |        Flags:16/little,          %% flags
        |        Decimals:8,               %% max shown decimal digits:
        |        0,  %% "filler"           %%   - 0x00 for integers and static strings
        |        0,                        %%   - 0x1f for dynamic strings, double, float
   281..|        Rest8/binary&gt;&gt; = Rest7,   %%   - 0x00 to 0x51 for decimals
        |      %% Here, if command was COM_FIELD_LIST {
        |      %%   default values: lenenc_str
        |      %% }
   281..|      &lt;&lt;&gt;&gt; = Rest8,
   281..|      #col{name = Name, type = Type, charset = Charset, length = Length,
        |           decimals = Decimals, flags = Flags}.
        |  
        |  %% -- text protocol --
        |  
        |  -spec decode_text_row(NumColumns :: integer(),
        |                        ColumnDefinitions :: [#col{}],
        |                        Data :: binary()) -&gt; [term()].
        |  decode_text_row(_NumColumns, ColumnDefs, Data) -&gt;
   137..|      decode_text_row_acc(ColumnDefs, Data, []).
        |  
        |  %% parses Data using ColDefs and builds the values Acc.
        |  decode_text_row_acc([ColDef | ColDefs], Data, Acc) -&gt;
   154..|      case Data of
        |          &lt;&lt;16#fb, Rest/binary&gt;&gt; -&gt;
        |              %% NULL
     1..|              decode_text_row_acc(ColDefs, Rest, [null | Acc]);
        |          _ -&gt;
        |              %% Every thing except NULL
   153..|              {Text, Rest} = lenenc_str(Data),
   153..|              Term = decode_text(ColDef, Text),
   153..|              decode_text_row_acc(ColDefs, Rest, [Term | Acc])
        |      end;
        |  decode_text_row_acc([], &lt;&lt;&gt;&gt;, Acc) -&gt;
   137..|      lists:reverse(Acc).
        |  
        |  %% @doc When receiving data in the text protocol, we get everything as binaries
        |  %% (except NULL). This function is used to parse these string values.
        |  decode_text(#col{type = T}, Text)
        |    when T == ?TYPE_TINY; T == ?TYPE_SHORT; T == ?TYPE_LONG; T == ?TYPE_LONGLONG;
        |         T == ?TYPE_INT24; T == ?TYPE_YEAR -&gt;
    64..|      binary_to_integer(Text);
        |  decode_text(#col{type = T}, Text)
        |    when T == ?TYPE_STRING; T == ?TYPE_VARCHAR; T == ?TYPE_VAR_STRING;
        |         T == ?TYPE_ENUM; T == ?TYPE_SET; T == ?TYPE_LONG_BLOB;
        |         T == ?TYPE_MEDIUM_BLOB; T == ?TYPE_BLOB; T == ?TYPE_TINY_BLOB;
        |         T == ?TYPE_GEOMETRY; T == ?TYPE_JSON -&gt;
        |      %% As of MySQL 5.6.21 we receive SET and ENUM values as STRING, i.e. we
        |      %% cannot convert them to atom() or sets:set(), etc.
    24..|      Text;
        |  decode_text(#col{type = ?TYPE_BIT, length = Length}, Text) -&gt;
        |      %% Convert to &lt;&lt;_:Length/bitstring&gt;&gt;
     5..|      decode_bitstring(Text, Length);
        |  decode_text(#col{type = T, decimals = S, length = L}, Text)
        |    when T == ?TYPE_DECIMAL; T == ?TYPE_NEWDECIMAL -&gt;
        |      %% Length is the max number of symbols incl. dot and minus sign, e.g. the
        |      %% number of digits plus 2.
    19..|      decode_decimal(Text, L - 2, S);
        |  decode_text(#col{type = ?TYPE_DATE},
        |              &lt;&lt;Y:4/binary, "-", M:2/binary, "-", D:2/binary&gt;&gt;) -&gt;
     6..|      {binary_to_integer(Y), binary_to_integer(M), binary_to_integer(D)};
        |  decode_text(#col{type = ?TYPE_TIME}, Text) -&gt;
    23..|      {match, [Sign, Hbin, Mbin, Sbin, Frac]} =
        |          re:run(Text,
        |                 &lt;&lt;"^(-?)(\\d+):(\\d+):(\\d+)(\\.?\\d*)$"&gt;&gt;,
        |                 [{capture, all_but_first, binary}]),
    23..|      H = binary_to_integer(Hbin),
    23..|      M = binary_to_integer(Mbin),
    23..|      S = binary_to_integer(Sbin),
    23..|      IsNeg = Sign == &lt;&lt;"-"&gt;&gt;,
    23..|      Fraction = case Frac of
    19..|          &lt;&lt;&gt;&gt; -&gt; 0;
     2..|          _ when not IsNeg -&gt; binary_to_float(&lt;&lt;"0", Frac/binary&gt;&gt;);
     2..|          _ when IsNeg -&gt; 1 - binary_to_float(&lt;&lt;"0", Frac/binary&gt;&gt;)
        |      end,
    23..|      Sec1 = H * 3600 + M * 60 + S,
    23..|      Sec2 = if IsNeg -&gt; -Sec1; true -&gt; Sec1 end,
    23..|      Sec3 = if IsNeg and (Fraction /= 0) -&gt; Sec2 - 1;
    21..|                true                      -&gt; Sec2
        |             end,
    23..|      {Days, {Hours, Minutes, Seconds}} = calendar:seconds_to_daystime(Sec3),
    23..|      {Days, {Hours, Minutes, Seconds + Fraction}};
        |  decode_text(#col{type = T},
        |              &lt;&lt;Y:4/binary, "-", M:2/binary, "-", D:2/binary, " ",
        |                H:2/binary, ":", Mi:2/binary, ":", S:2/binary&gt;&gt;)
        |    when T == ?TYPE_TIMESTAMP; T == ?TYPE_DATETIME -&gt;
        |      %% Without fractions.
     9..|      {{binary_to_integer(Y), binary_to_integer(M), binary_to_integer(D)},
        |       {binary_to_integer(H), binary_to_integer(Mi), binary_to_integer(S)}};
        |  decode_text(#col{type = T},
        |              &lt;&lt;Y:4/binary, "-", M:2/binary, "-", D:2/binary, " ",
        |                H:2/binary, ":", Mi:2/binary, ":", FloatS/binary&gt;&gt;)
        |    when T == ?TYPE_TIMESTAMP; T == ?TYPE_DATETIME -&gt;
        |      %% With fractions.
     2..|      {{binary_to_integer(Y), binary_to_integer(M), binary_to_integer(D)},
        |       {binary_to_integer(H), binary_to_integer(Mi), binary_to_float(FloatS)}};
        |  decode_text(#col{type = T}, Text) when T == ?TYPE_FLOAT;
        |                                                       T == ?TYPE_DOUBLE -&gt;
    28..|      try binary_to_float(Text)
        |      catch error:badarg -&gt;
    10..|          try binary_to_integer(Text) of
     9..|              Int -&gt; float(Int)
        |          catch error:badarg -&gt;
        |              %% It is something like "4e75" that must be turned into "4.0e75"
     1..|              binary_to_float(binary:replace(Text, &lt;&lt;"e"&gt;&gt;, &lt;&lt;".0e"&gt;&gt;))
        |          end
        |      end.
        |  
        |  %% -- binary protocol --
        |  
        |  %% @doc If NumColumns is non-zero, fetches this number of column definitions
        |  %% and an EOF packet. Used by prepare/3.
        |  fetch_column_definitions_if_any(0, _SockModule, _Socket, SeqNum) -&gt;
   101..|      {[], SeqNum};
        |  fetch_column_definitions_if_any(N, SockModule, Socket, SeqNum) -&gt;
   113..|      {ok, Defs, SeqNum1} = fetch_column_definitions(SockModule, Socket, SeqNum,
        |                                                     N, []),
   113..|      {ok, ?eof_pattern, SeqNum2} = recv_packet(SockModule, Socket, SeqNum1),
   113..|      {Defs, SeqNum2}.
        |  
        |  %% @doc Decodes a packet representing a row in a binary result set.
        |  %% It consists of a 0 byte, then a null bitmap, then the values.
        |  %% Returns a list of length NumColumns with terms of appropriate types for each
        |  %% MySQL type in ColumnTypes.
        |  -spec decode_binary_row(NumColumns :: integer(),
        |                          ColumnDefs :: [#col{}],
        |                          Data :: binary()) -&gt; [term()].
        |  decode_binary_row(NumColumns, ColumnDefs, &lt;&lt;0, Data/binary&gt;&gt;) -&gt;
   113..|      {NullBitMap, Rest} = null_bitmap_decode(NumColumns, Data, 2),
   113..|      decode_binary_row_acc(ColumnDefs, NullBitMap, Rest, []).
        |  
        |  %% @doc Accumulating helper for decode_binary_row/3.
        |  decode_binary_row_acc([_|ColDefs], &lt;&lt;1:1, NullBitMap/bitstring&gt;&gt;, Data, Acc) -&gt;
        |      %% NULL
     1..|      decode_binary_row_acc(ColDefs, NullBitMap, Data, [null | Acc]);
        |  decode_binary_row_acc([ColDef | ColDefs], &lt;&lt;0:1, NullBitMap/bitstring&gt;&gt;, Data,
        |                        Acc) -&gt;
        |      %% Not NULL
   122..|      {Term, Rest} = decode_binary(ColDef, Data),
   122..|      decode_binary_row_acc(ColDefs, NullBitMap, Rest, [Term | Acc]);
        |  decode_binary_row_acc([], _, &lt;&lt;&gt;&gt;, Acc) -&gt;
   113..|      lists:reverse(Acc).
        |  
        |  %% @doc Decodes a null bitmap as stored by MySQL and returns it in a strait
        |  %% bitstring counting bits from left to right in a tuple with remaining data.
        |  %%
        |  %% In the MySQL null bitmap the bits are stored counting bytes from the left and
        |  %% bits within each byte from the right. (Sort of little endian.)
        |  -spec null_bitmap_decode(NumColumns :: integer(), Data :: binary(),
        |                           BitOffset :: integer()) -&gt;
        |      {NullBitstring :: bitstring(), Rest :: binary()}.
        |  null_bitmap_decode(NumColumns, Data, BitOffset) -&gt;
        |      %% Binary shift right by 3 is equivallent to integer division by 8.
   114..|      BitMapLength = (NumColumns + BitOffset + 7) bsr 3,
   114..|      &lt;&lt;NullBitstring0:BitMapLength/binary, Rest/binary&gt;&gt; = Data,
   114..|      &lt;&lt;_:BitOffset, NullBitstring:NumColumns/bitstring, _/bitstring&gt;&gt; =
   116..|          &lt;&lt; &lt;&lt;(reverse_byte(B))/binary&gt;&gt; || &lt;&lt;B:1/binary&gt;&gt; &lt;= NullBitstring0 &gt;&gt;,
   114..|      {NullBitstring, Rest}.
        |  
        |  %% @doc The reverse of null_bitmap_decode/3. The number of columns is taken to
        |  %% be the number of bits in NullBitstring. Returns the MySQL null bitmap as a
        |  %% binary (i.e. full bytes). BitOffset is the number of unused bits that should
        |  %% be inserted before the other bits.
        |  -spec null_bitmap_encode(bitstring(), integer()) -&gt; binary().
        |  null_bitmap_encode(NullBitstring, BitOffset) -&gt;
    82..|      PayloadLength = bit_size(NullBitstring) + BitOffset,
        |      %% Round up to a multiple of 8.
    82..|      BitMapLength = (PayloadLength + 7) band bnot 7,
    82..|      PadBitsLength = BitMapLength - PayloadLength,
    82..|      PaddedBitstring = &lt;&lt;0:BitOffset, NullBitstring/bitstring, 0:PadBitsLength&gt;&gt;,
    82..|      &lt;&lt; &lt;&lt;(reverse_byte(B))/binary&gt;&gt; || &lt;&lt;B:1/binary&gt;&gt; &lt;= PaddedBitstring &gt;&gt;.
        |  
        |  %% Reverses the bits in a byte.
        |  reverse_byte(&lt;&lt;A:1, B:1, C:1, D:1, E:1, F:1, G:1, H:1&gt;&gt;) -&gt;
   200..|      &lt;&lt;H:1, G:1, F:1, E:1, D:1, C:1, B:1, A:1&gt;&gt;.
        |  
        |  %% @doc Used for executing prepared statements. The bit offset whould be 0 in
        |  %% this case.
        |  -spec build_null_bitmap([any()]) -&gt; binary().
        |  build_null_bitmap(Values) -&gt;
    81..|      Bits = &lt;&lt; &lt;&lt;(case V of null -&gt; 1; _ -&gt; 0 end):1&gt;&gt; || V &lt;- Values &gt;&gt;,
    81..|      null_bitmap_encode(Bits, 0).
        |  
        |  %% Decodes a value as received in the 'binary protocol' result set.
        |  %%
        |  %% The types are type constants for the binary protocol, such as
        |  %% ProtocolBinary::MYSQL_TYPE_STRING. In the guide "MySQL Internals" these are
        |  %% not listed, but we assume that are the same as for the text protocol.
        |  -spec decode_binary(ColDef :: #col{}, Data :: binary()) -&gt;
        |      {Term :: term(), Rest :: binary()}.
        |  decode_binary(#col{type = T}, Data)
        |    when T == ?TYPE_STRING; T == ?TYPE_VARCHAR; T == ?TYPE_VAR_STRING;
        |         T == ?TYPE_ENUM; T == ?TYPE_SET; T == ?TYPE_LONG_BLOB;
        |         T == ?TYPE_MEDIUM_BLOB; T == ?TYPE_BLOB; T == ?TYPE_TINY_BLOB;
        |         T == ?TYPE_GEOMETRY; T == ?TYPE_JSON -&gt;
        |      %% As of MySQL 5.6.21 we receive SET and ENUM values as STRING, i.e. we
        |      %% cannot convert them to atom() or sets:set(), etc.
     5..|      lenenc_str(Data);
        |  decode_binary(#col{type = ?TYPE_LONGLONG, flags = F},
        |                &lt;&lt;Value:64/signed-little, Rest/binary&gt;&gt;)
        |    when F band ?UNSIGNED_FLAG == 0 -&gt;
     7..|      {Value, Rest};
        |  decode_binary(#col{type = ?TYPE_LONGLONG, flags = F},
        |                &lt;&lt;Value:64/unsigned-little, Rest/binary&gt;&gt;)
        |    when F band ?UNSIGNED_FLAG /= 0 -&gt;
     2..|      {Value, Rest};
        |  decode_binary(#col{type = T, flags = F},
        |                &lt;&lt;Value:32/signed-little, Rest/binary&gt;&gt;)
        |    when (T == ?TYPE_LONG orelse T == ?TYPE_INT24) andalso
        |         F band ?UNSIGNED_FLAG == 0 -&gt;
    13..|      {Value, Rest};
        |  decode_binary(#col{type = T, flags = F},
        |                &lt;&lt;Value:32/unsigned-little, Rest/binary&gt;&gt;)
        |    when (T == ?TYPE_LONG orelse T == ?TYPE_INT24) andalso
        |         F band ?UNSIGNED_FLAG /= 0 -&gt;
     2..|      {Value, Rest};
        |  decode_binary(#col{type = ?TYPE_SHORT, flags = F},
        |                &lt;&lt;Value:16/signed-little, Rest/binary&gt;&gt;)
        |    when F band ?UNSIGNED_FLAG == 0 -&gt;
     4..|      {Value, Rest};
        |  decode_binary(#col{type = T, flags = F},
        |                &lt;&lt;Value:16/unsigned-little, Rest/binary&gt;&gt;)
        |    when (T == ?TYPE_SHORT orelse T == ?TYPE_YEAR) andalso
        |         F band ?UNSIGNED_FLAG /= 0 -&gt;
     3..|      {Value, Rest};
        |  decode_binary(#col{type = ?TYPE_TINY, flags = F},
        |                &lt;&lt;Value:8/unsigned, Rest/binary&gt;&gt;)
        |    when F band ?UNSIGNED_FLAG /= 0 -&gt;
     2..|      {Value, Rest};
        |  decode_binary(#col{type = ?TYPE_TINY, flags = F},
        |                &lt;&lt;Value:8/signed, Rest/binary&gt;&gt;)
        |    when F band ?UNSIGNED_FLAG == 0 -&gt;
     4..|      {Value, Rest};
        |  decode_binary(#col{type = T, decimals = S, length = L}, Data)
        |    when T == ?TYPE_DECIMAL; T == ?TYPE_NEWDECIMAL -&gt;
        |      %% Length is the max number of symbols incl. dot and minus sign, e.g. the
        |      %% number of digits plus 2.
    17..|      {Binary, Rest} = lenenc_str(Data),
    17..|      {decode_decimal(Binary, L - 2, S), Rest};
        |  decode_binary(#col{type = ?TYPE_DOUBLE},
        |                &lt;&lt;Value:64/float-little, Rest/binary&gt;&gt;) -&gt;
     1..|      {Value, Rest};
        |  decode_binary(#col{type = ?TYPE_FLOAT}, &lt;&lt;0.0:32/float-little, Rest/binary&gt;&gt;) -&gt;
        |      %% TYPE_FLOAT conversation fails on math:log10(0.0)
     1..|      {0.0, Rest};
        |  decode_binary(#col{type = ?TYPE_FLOAT},
        |                &lt;&lt;Value:32/float-little, Rest/binary&gt;&gt;) -&gt;
        |      %% There is a precision loss when storing and fetching a 32-bit float.
        |      %% In the text protocol, it is obviously rounded. Storing 3.14 in a FLOAT
        |      %% column and fetching it using the text protocol, we get "3.14" which we
        |      %% parse to the Erlang double as close as possible to 3.14. Fetching the
        |      %% same value as a binary 32-bit float, we get 3.140000104904175. To achieve
        |      %% the same rounding after receiving it as a 32-bit float, we try to do the
        |      %% same rounding here as MySQL does when sending it over the text protocol.
        |      %%
        |      %% This comment explains the idea:
        |      %%
        |      %%     Posted by Geoffrey Downs on March 10 2011 10:26am
        |      %%
        |      %%     Following up... I *think* this is correct for the default float
        |      %%     columns in mysql:
        |      %%
        |      %%     var yourNumber = some floating point value
        |      %%     max decimal precision = 10 ^ (-5 + flooring(yourNumber log 10))
        |      %%     So:
        |      %%     0 &lt; x &lt; 10 -&gt; max precision is 0.00001
        |      %%     10 &lt;= x &lt; 100 -&gt; max precision is 0.0001
        |      %%     100 &lt;= x &lt; 1000 -&gt; max precision is 0.001
        |      %%     etc.
        |      %%
        |      %% (From http://dev.mysql.com/doc/refman/5.7/en/problems-with-float.html
        |      %% fetched 10 Nov 2014)
        |      %%
        |      %% The above is almost correct, except for the example in the interval
        |      %% 0 &lt; x &lt; 1. There are 6 significant digits also for these numbers.
        |      %%
        |      %% Now, instead of P = 0.00001 we want the inverse 100000.0 but if we
        |      %% compute Factor = 1 / P we get a precision loss, so instead we do this:
    27..|      Factor = math:pow(10, flooring(6 - math:log10(abs(Value)))),
    27..|      RoundedValue = round(Value * Factor) / Factor,
    27..|      {RoundedValue, Rest};
        |  decode_binary(#col{type = ?TYPE_BIT, length = Length}, Data) -&gt;
     4..|      {Binary, Rest} = lenenc_str(Data),
        |      %% Convert to &lt;&lt;_:Length/bitstring&gt;&gt;
     4..|      {decode_bitstring(Binary, Length), Rest};
        |  decode_binary(#col{type = ?TYPE_DATE}, &lt;&lt;Length, Data/binary&gt;&gt;) -&gt;
        |      %% Coded in the same way as DATETIME and TIMESTAMP below, but returned in
        |      %% a simple triple.
     5..|      case {Length, Data} of
     2..|          {0, _} -&gt; {{0, 0, 0}, Data};
     3..|          {4, &lt;&lt;Y:16/little, M, D, Rest/binary&gt;&gt;} -&gt; {{Y, M, D}, Rest}
        |      end;
        |  decode_binary(#col{type = T}, &lt;&lt;Length, Data/binary&gt;&gt;)
        |    when T == ?TYPE_DATETIME; T == ?TYPE_TIMESTAMP -&gt;
        |      %% length (1) -- number of bytes following (valid values: 0, 4, 7, 11)
     9..|      case {Length, Data} of
        |          {0, _} -&gt;
     2..|              {{{0, 0, 0}, {0, 0, 0}}, Data};
        |          {4, &lt;&lt;Y:16/little, M, D, Rest/binary&gt;&gt;} -&gt;
     2..|              {{{Y, M, D}, {0, 0, 0}}, Rest};
        |          {7, &lt;&lt;Y:16/little, M, D, H, Mi, S, Rest/binary&gt;&gt;} -&gt;
     3..|              {{{Y, M, D}, {H, Mi, S}}, Rest};
        |          {11, &lt;&lt;Y:16/little, M, D, H, Mi, S, Micro:32/little, Rest/binary&gt;&gt;} -&gt;
     2..|              {{{Y, M, D}, {H, Mi, S + 0.000001 * Micro}}, Rest}
        |      end;
        |  decode_binary(#col{type = ?TYPE_TIME}, &lt;&lt;Length, Data/binary&gt;&gt;) -&gt;
        |      %% length (1) -- number of bytes following (valid values: 0, 8, 12)
        |      %% is_negative (1) -- (1 if minus, 0 for plus)
        |      %% days (4) -- days
        |      %% hours (1) -- hours
        |      %% minutes (1) -- minutes
        |      %% seconds (1) -- seconds
        |      %% micro_seconds (4) -- micro-seconds
    21..|      case {Length, Data} of
        |          {0, _} -&gt;
     2..|              {{0, {0, 0, 0}}, Data};
        |          {8, &lt;&lt;0, D:32/little, H, M, S, Rest/binary&gt;&gt;} -&gt;
     5..|              {{D, {H, M, S}}, Rest};
        |          {12, &lt;&lt;0, D:32/little, H, M, S, Micro:32/little, Rest/binary&gt;&gt;} -&gt;
     2..|              {{D, {H, M, S + 0.000001 * Micro}}, Rest};
        |          {8, &lt;&lt;1, D:32/little, H, M, S, Rest/binary&gt;&gt;} -&gt;
        |              %% Negative time. Example: '-00:00:01' --&gt; {-1,{23,59,59}}
    10..|              Seconds = ((D * 24 + H) * 60 + M) * 60 + S,
        |              %Seconds = D * 86400 + calendar:time_to_seconds({H, M, S}),
    10..|              {calendar:seconds_to_daystime(-Seconds), Rest};
        |          {12, &lt;&lt;1, D:32/little, H, M, S, Micro:32/little, Rest/binary&gt;&gt;}
        |            when Micro &gt; 0 -&gt;
        |              %% Negate and convert to seconds, excl fractions
     2..|              Seconds = -(((D * 24 + H) * 60 + M) * 60 + S),
        |              %Seconds = -D * 86400 - calendar:time_to_seconds({H, M, S}),
        |              %% Subtract 1 second for the fractions
     2..|              {Days, {Hours, Minutes, Sec}} =
        |                  calendar:seconds_to_daystime(Seconds - 1),
        |              %% Adding the fractions to Sec again makes it a float
     2..|              {{Days, {Hours, Minutes, Sec + 1 - 0.000001 * Micro}}, Rest}
        |      end.
        |  
        |  %% @doc Like trunc/1 but towards negative infinity instead of towards zero.
        |  flooring(Value) -&gt;
    27..|      Trunc = trunc(Value),
    27..|      if
    21..|          Trunc =&lt; Value -&gt; Trunc;
     6..|          Trunc &gt; Value -&gt; Trunc - 1 %% for negative values
        |      end.
        |  
        |  %% @doc Encodes a term reprenting av value as a binary for use in the binary
        |  %% protocol. As this is used to encode parameters for prepared statements, the
        |  %% encoding is in its required form, namely `&lt;&lt;Type:8, Sign:8, Value/binary&gt;&gt;'.
        |  -spec encode_param(term()) -&gt; {TypeAndSign :: binary(), Data :: binary()}.
        |  encode_param(null) -&gt;
     1..|      {&lt;&lt;?TYPE_NULL, 0&gt;&gt;, &lt;&lt;&gt;&gt;};
        |  encode_param(Value) when is_binary(Value) -&gt;
    10..|      EncLength = lenenc_int_encode(byte_size(Value)),
    10..|      {&lt;&lt;?TYPE_VAR_STRING, 0&gt;&gt;, &lt;&lt;EncLength/binary, Value/binary&gt;&gt;};
        |  encode_param(Value) when is_list(Value) -&gt;
     1..|      encode_param(unicode:characters_to_binary(Value));
        |  encode_param(Value) when is_integer(Value), Value &gt;= 0 -&gt;
        |      %% We send positive integers with the 'unsigned' flag set.
    30..|      if
        |          Value =&lt; 16#ff -&gt;
    21..|              {&lt;&lt;?TYPE_TINY, 16#80&gt;&gt;, &lt;&lt;Value:8&gt;&gt;};
        |          Value =&lt; 16#ffff -&gt;
     3..|              {&lt;&lt;?TYPE_SHORT, 16#80&gt;&gt;, &lt;&lt;Value:16/little&gt;&gt;};
        |          Value =&lt; 16#ffffffff -&gt;
     3..|              {&lt;&lt;?TYPE_LONG, 16#80&gt;&gt;, &lt;&lt;Value:32/little&gt;&gt;};
        |          Value =&lt; 16#ffffffffffffffff -&gt;
     2..|              {&lt;&lt;?TYPE_LONGLONG, 16#80&gt;&gt;, &lt;&lt;Value:64/little&gt;&gt;};
        |          true -&gt;
        |              %% If larger than a 64-bit int we send it as a string. MySQL does
        |              %% silently cast strings in aithmetic expressions. Also, DECIMALs
        |              %% are always sent as strings.
     1..|              encode_param(integer_to_binary(Value))
        |      end;
        |  encode_param(Value) when is_integer(Value), Value &lt; 0 -&gt;
     7..|      if
        |          Value &gt;= -16#80 -&gt;
     2..|              {&lt;&lt;?TYPE_TINY, 0&gt;&gt;, &lt;&lt;Value:8&gt;&gt;};
        |          Value &gt;= -16#8000 -&gt;
     1..|              {&lt;&lt;?TYPE_SHORT, 0&gt;&gt;, &lt;&lt;Value:16/little&gt;&gt;};
        |          Value &gt;= -16#80000000 -&gt;
     2..|              {&lt;&lt;?TYPE_LONG, 0&gt;&gt;, &lt;&lt;Value:32/little&gt;&gt;};
        |          Value &gt;= -16#8000000000000000 -&gt;
     1..|              {&lt;&lt;?TYPE_LONGLONG, 0&gt;&gt;, &lt;&lt;Value:64/little&gt;&gt;};
        |          true -&gt;
     1..|              encode_param(integer_to_binary(Value))
        |      end;
        |  encode_param(Value) when is_float(Value) -&gt;
    28..|      {&lt;&lt;?TYPE_DOUBLE, 0&gt;&gt;, &lt;&lt;Value:64/float-little&gt;&gt;};
        |  encode_param(Value) when is_bitstring(Value) -&gt;
     2..|      Binary = encode_bitstring(Value),
     2..|      EncLength = lenenc_int_encode(byte_size(Binary)),
     2..|      {&lt;&lt;?TYPE_VAR_STRING, 0&gt;&gt;, &lt;&lt;EncLength/binary, Binary/binary&gt;&gt;};
        |  encode_param({Y, M, D}) -&gt;
        |      %% calendar:date()
     3..|      {&lt;&lt;?TYPE_DATE, 0&gt;&gt;, &lt;&lt;4, Y:16/little, M, D&gt;&gt;};
        |  encode_param({{Y, M, D}, {0, 0, 0}}) -&gt;
        |      %% Datetime at midnight
     2..|      {&lt;&lt;?TYPE_DATETIME, 0&gt;&gt;, &lt;&lt;4, Y:16/little, M, D&gt;&gt;};
        |  encode_param({{Y, M, D}, {H, Mi, S}}) when is_integer(S) -&gt;
        |      %% calendar:datetime()
     2..|      {&lt;&lt;?TYPE_DATETIME, 0&gt;&gt;, &lt;&lt;7, Y:16/little, M, D, H, Mi, S&gt;&gt;};
        |  encode_param({{Y, M, D}, {H, Mi, S}}) when is_float(S) -&gt;
        |      %% calendar:datetime() with a float for seconds. This way it looks very
        |      %% similar to a datetime. Microseconds in MySQL timestamps are possible but
        |      %% not very common.
     1..|      Sec = trunc(S),
     1..|      Micro = round(1000000 * (S - Sec)),
     1..|      {&lt;&lt;?TYPE_DATETIME, 0&gt;&gt;, &lt;&lt;11, Y:16/little, M, D, H, Mi, Sec,
        |                                Micro:32/little&gt;&gt;};
        |  encode_param({D, {H, M, S}}) when is_integer(S), D &gt;= 0 -&gt;
        |      %% calendar:seconds_to_daystime()
     4..|      {&lt;&lt;?TYPE_TIME, 0&gt;&gt;, &lt;&lt;8, 0, D:32/little, H, M, S&gt;&gt;};
        |  encode_param({D, {H, M, S}}) when is_integer(S), D &lt; 0 -&gt;
        |      %% Convert to seconds, negate and convert back to daystime form.
        |      %% Then set the minus flag.
     6..|      Seconds = ((D * 24 + H) * 60 + M) * 60 + S,
     6..|      {D1, {H1, M1, S1}} = calendar:seconds_to_daystime(-Seconds),
     6..|      {&lt;&lt;?TYPE_TIME, 0&gt;&gt;, &lt;&lt;8, 1, D1:32/little, H1, M1, S1&gt;&gt;};
        |  encode_param({D, {H, M, S}}) when is_float(S), D &gt;= 0 -&gt;
     1..|      S1 = trunc(S),
     1..|      Micro = round(1000000 * (S - S1)),
     1..|      {&lt;&lt;?TYPE_TIME, 0&gt;&gt;, &lt;&lt;12, 0, D:32/little, H, M, S1, Micro:32/little&gt;&gt;};
        |  encode_param({D, {H, M, S}}) when is_float(S), S &gt; 0.0, D &lt; 0 -&gt;
     1..|      IntS = trunc(S),
     1..|      Micro = round(1000000 * (1 - S + IntS)),
     1..|      Seconds = (D * 24 + H) * 3600 + M * 60 + IntS + 1,
     1..|      {D1, {M1, H1, S1}} = calendar:seconds_to_daystime(-Seconds),
     1..|      {&lt;&lt;?TYPE_TIME, 0&gt;&gt;, &lt;&lt;12, 1, D1:32/little, H1, M1, S1, Micro:32/little&gt;&gt;};
        |  encode_param({D, {H, M, 0.0}}) -&gt;
     1..|      encode_param({D, {H, M, 0}}).
        |  
        |  %% -- Value representation in both the text and binary protocols --
        |  
        |  %% @doc Convert to `&lt;&lt;_:Length/bitstring&gt;&gt;'
        |  decode_bitstring(Binary, Length) -&gt;
     9..|      PaddingLength = bit_size(Binary) - Length,
     9..|      &lt;&lt;_:PaddingLength/bitstring, Bitstring:Length/bitstring&gt;&gt; = Binary,
     9..|      Bitstring.
        |  
        |  encode_bitstring(Bitstring) -&gt;
     2..|      Size = bit_size(Bitstring),
     2..|      PaddingSize = byte_size(Bitstring) * 8 - Size,
     2..|      &lt;&lt;0:PaddingSize, Bitstring:Size/bitstring&gt;&gt;.
        |  
        |  decode_decimal(Bin, _P, 0) -&gt;
     8..|      binary_to_integer(Bin);
        |  decode_decimal(Bin, P, S) when P =&lt; 15, S &gt; 0 -&gt;
    16..|      binary_to_float(Bin);
        |  decode_decimal(Bin, P, S) when P &gt;= 16, S &gt; 0 -&gt;
    12..|      Bin.
        |  
        |  %% -- Protocol basics: packets --
        |  
        |  %% @doc Wraps Data in packet headers, sends it by calling SockModule:send/2 with
        |  %% Socket and returns {ok, SeqNum1} where SeqNum1 is the next sequence number.
        |  -spec send_packet(atom(), term(), Data :: binary(), SeqNum :: integer()) -&gt;
        |      {ok, NextSeqNum :: integer()}.
        |  send_packet(SockModule, Socket, Data, SeqNum) -&gt;
   887..|      {WithHeaders, SeqNum1} = add_packet_headers(Data, SeqNum),
   887..|      ok = SockModule:send(Socket, WithHeaders),
   886..|      {ok, SeqNum1}.
        |  
        |  %% @see recv_packet/4
        |  recv_packet(SockModule, Socket, SeqNum) -&gt;
  1472..|      recv_packet(SockModule, Socket, infinity, SeqNum).
        |  
        |  %% @doc Receives data by calling SockModule:recv/2 and removes the packet
        |  %% headers. Returns the packet contents and the next packet sequence number.
        |  -spec recv_packet(atom(), term(), timeout(), integer() | any) -&gt;
        |      {ok, Data :: binary(), NextSeqNum :: integer()} | {error, term()}.
        |  recv_packet(SockModule, Socket, Timeout, SeqNum) -&gt;
  2128..|      recv_packet(SockModule, Socket, Timeout, SeqNum, &lt;&lt;&gt;&gt;).
        |  
        |  %% @doc Accumulating helper for recv_packet/4
        |  -spec recv_packet(atom(), term(), timeout(), integer() | any, binary()) -&gt;
        |      {ok, Data :: binary(), NextSeqNum :: integer()} | {error, term()}.
        |  recv_packet(SockModule, Socket, Timeout, ExpectSeqNum, Acc) -&gt;
  2128..|      case SockModule:recv(Socket, 4, Timeout) of
        |          {ok, Header} -&gt;
  2109..|              {Size, SeqNum, More} = parse_packet_header(Header),
  2109..|              true = SeqNum == ExpectSeqNum orelse ExpectSeqNum == any,
  2109..|              {ok, Body} = SockModule:recv(Socket, Size),
  2109..|              Acc1 = &lt;&lt;Acc/binary, Body/binary&gt;&gt;,
  2109..|              NextSeqNum = (SeqNum + 1) band 16#ff,
  2109..|              case More of
  2109..|                  false -&gt; {ok, Acc1, NextSeqNum};
<font color=red>     0..|                  true  -&gt; recv_packet(SockModule, Socket, Timeout, NextSeqNum,</font>
        |                                       Acc1)
        |              end;
        |          {error, Reason} -&gt;
    19..|              {error, Reason}
        |      end.
        |  
        |  %% @doc Parses a packet header (32 bits) and returns a tuple.
        |  %%
        |  %% The client should first read a header and parse it. Then read PacketLength
        |  %% bytes. If there are more packets, read another header and read a new packet
        |  %% length of payload until there are no more packets. The seq num should
        |  %% increment from 0 and may wrap around at 255 back to 0.
        |  %%
        |  %% When all packets are read and the payload of all packets are concatenated, it
        |  %% can be parsed using parse_response/1, etc. depending on what type of response
        |  %% is expected.
        |  -spec parse_packet_header(PackerHeader :: binary()) -&gt;
        |      {PacketLength :: integer(),
        |       SeqNum :: integer(),
        |       MorePacketsExist :: boolean()}.
        |  parse_packet_header(&lt;&lt;PacketLength:24/little-integer, SeqNum:8/integer&gt;&gt;) -&gt;
  2110..|      {PacketLength, SeqNum, PacketLength == 16#ffffff}.
        |  
        |  %% @doc Splits a packet body into chunks and wraps them in headers. The
        |  %% resulting list is ready to be sent to the socket. The result is built as a
        |  %% list to avoid copying large binaries.
        |  -spec add_packet_headers(Data :: binary(), SeqNum :: integer()) -&gt;
        |      {PacketsWithHeaders :: iodata(), NextSeqNum :: integer()}.
        |  add_packet_headers(&lt;&lt;Payload:16#ffffff/binary, Rest/binary&gt;&gt;, SeqNum) -&gt;
     4..|      SeqNum1 = (SeqNum + 1) band 16#ff,
     4..|      {Packets, NextSeqNum} = add_packet_headers(Rest, SeqNum1),
     4..|      Header = &lt;&lt;16#ffffff:24/little, SeqNum:8&gt;&gt;,
     4..|      {[Header, Payload | Packets], NextSeqNum};
        |  add_packet_headers(Bin, SeqNum) when byte_size(Bin) &lt; 16#ffffff -&gt;
   891..|      NextSeqNum = (SeqNum + 1) band 16#ff,
   891..|      Header = &lt;&lt;(byte_size(Bin)):24/little, SeqNum:8&gt;&gt;,
   891..|      {[Header, Bin], NextSeqNum}.
        |  
        |  -spec parse_ok_packet(binary()) -&gt; #ok{}.
        |  parse_ok_packet(&lt;&lt;?OK:8, Rest/binary&gt;&gt;) -&gt;
   417..|      {AffectedRows, Rest1} = lenenc_int(Rest),
   417..|      {InsertId, Rest2} = lenenc_int(Rest1),
   417..|      &lt;&lt;StatusFlags:16/little, WarningCount:16/little, Msg/binary&gt;&gt; = Rest2,
        |      %% We have CLIENT_PROTOCOL_41 but not CLIENT_SESSION_TRACK enabled. The
        |      %% protocol is conditional. This is from the protocol documentation:
        |      %%
        |      %% if capabilities &amp; CLIENT_PROTOCOL_41 {
        |      %%   int&lt;2&gt; status_flags
        |      %%   int&lt;2&gt; warning_count
        |      %% } elseif capabilities &amp; CLIENT_TRANSACTIONS {
        |      %%   int&lt;2&gt; status_flags
        |      %% }
        |      %% if capabilities &amp; CLIENT_SESSION_TRACK {
        |      %%   string&lt;lenenc&gt; info
        |      %%   if status_flags &amp; SERVER_SESSION_STATE_CHANGED {
        |      %%     string&lt;lenenc&gt; session_state_changes
        |      %%   }
        |      %% } else {
        |      %%   string&lt;EOF&gt; info
        |      %% }
   417..|      #ok{affected_rows = AffectedRows,
        |          insert_id = InsertId,
        |          status = StatusFlags,
        |          warning_count = WarningCount,
        |          msg = Msg}.
        |  
        |  -spec parse_error_packet(binary()) -&gt; #error{}.
        |  parse_error_packet(&lt;&lt;?ERROR:8, ErrNo:16/little, "#", SQLState:5/binary-unit:8,
        |                       Msg/binary&gt;&gt;) -&gt;
        |      %% Error, 4.1 protocol.
        |      %% (Older protocol: &lt;&lt;?ERROR:8, ErrNo:16/little, Msg/binary&gt;&gt;)
    11..|      #error{code = ErrNo, state = SQLState, msg = Msg}.
        |  
        |  -spec parse_eof_packet(binary()) -&gt; #eof{}.
        |  parse_eof_packet(&lt;&lt;?EOF:8, NumWarnings:16/little, StatusFlags:16/little&gt;&gt;) -&gt;
        |      %% EOF packet, 4.1 protocol.
        |      %% (Older protocol: &lt;&lt;?EOF:8&gt;&gt;)
   256..|      #eof{status = StatusFlags, warning_count = NumWarnings}.
        |  
        |  -spec parse_auth_method_switch(binary()) -&gt; #auth_method_switch{}.
        |  parse_auth_method_switch(AMSData) -&gt;
<font color=red>     0..|      {AuthPluginName, AuthPluginData} = get_null_terminated_binary(AMSData),</font>
<font color=red>     0..|      #auth_method_switch{</font>
        |         auth_plugin_name = AuthPluginName,
        |         auth_plugin_data = AuthPluginData
        |        }.
        |  
        |  -spec get_null_terminated_binary(binary()) -&gt; {Binary :: binary(),
        |                                                 Rest :: binary()}.
        |  get_null_terminated_binary(In) -&gt;
<font color=red>     0..|      get_null_terminated_binary(In, &lt;&lt;&gt;&gt;).</font>
        |  
        |  get_null_terminated_binary(&lt;&lt;0, Rest/binary&gt;&gt;, Acc) -&gt;
<font color=red>     0..|      {Acc, Rest};</font>
        |  get_null_terminated_binary(&lt;&lt;Ch, Rest/binary&gt;&gt;, Acc) -&gt;
<font color=red>     0..|      get_null_terminated_binary(Rest, &lt;&lt;Acc/binary, Ch&gt;&gt;).</font>
        |  
        |  -spec hash_password(Password :: iodata(), Salt :: binary()) -&gt; Hash :: binary().
        |  hash_password(Password, Salt) -&gt;
        |      %% From the "MySQL Internals" manual:
        |      %% SHA1( password ) XOR SHA1( "20-bytes random data from server" &lt;concat&gt;
        |      %%                            SHA1( SHA1( password ) ) )
        |      %% ----
        |      %% Make sure the salt is exactly 20 bytes.
        |      %%
        |      %% The auth data is obviously nul-terminated. For the "native" auth
        |      %% method, it should be a 20 byte salt, so let's trim it in this case.
    23..|      PasswordBin = case erlang:is_binary(Password) of
     2..|          true -&gt; Password;
    21..|          false -&gt; erlang:iolist_to_binary(Password)
        |      end,
    23..|      case PasswordBin =:= &lt;&lt;&gt;&gt; of
     1..|          true -&gt; &lt;&lt;&gt;&gt;;
    22..|          false -&gt; hash_non_empty_password(Password, Salt)
        |      end.
        |  
        |  -spec hash_non_empty_password(Password :: iodata(), Salt :: binary()) -&gt;
        |      Hash :: binary().
        |  hash_non_empty_password(Password, Salt) -&gt;
    22..|      Salt1 = case Salt of
    21..|          &lt;&lt;SaltNoNul:20/binary-unit:8, 0&gt;&gt; -&gt; SaltNoNul;
     1..|          _ when size(Salt) == 20           -&gt; Salt
        |      end,
        |      %% Hash as described above.
    22..|      &lt;&lt;Hash1Num:160&gt;&gt; = Hash1 = crypto:hash(sha, Password),
    22..|      Hash2 = crypto:hash(sha, Hash1),
    22..|      &lt;&lt;Hash3Num:160&gt;&gt; = crypto:hash(sha, &lt;&lt;Salt1/binary, Hash2/binary&gt;&gt;),
    22..|      &lt;&lt;(Hash1Num bxor Hash3Num):160&gt;&gt;.
        |  
        |  %% --- Lowlevel: variable length integers and strings ---
        |  
        |  %% lenenc_int/1 decodes length-encoded-integer values
        |  -spec lenenc_int(Input :: binary()) -&gt; {Value :: integer(), Rest :: binary()}.
  3237..|  lenenc_int(&lt;&lt;Value:8, Rest/bits&gt;&gt;) when Value &lt; 251 -&gt; {Value, Rest};
     1..|  lenenc_int(&lt;&lt;16#fc:8, Value:16/little, Rest/binary&gt;&gt;) -&gt; {Value, Rest};
     1..|  lenenc_int(&lt;&lt;16#fd:8, Value:24/little, Rest/binary&gt;&gt;) -&gt; {Value, Rest};
     1..|  lenenc_int(&lt;&lt;16#fe:8, Value:64/little, Rest/binary&gt;&gt;) -&gt; {Value, Rest}.
        |  
        |  %% Length-encoded-integer encode. Appends the encoded value to Acc.
        |  %% Values not representable in 64 bits are not accepted.
        |  -spec lenenc_int_encode(0..16#ffffffffffffffff) -&gt; binary().
        |  lenenc_int_encode(Value) when Value &gt;= 0 -&gt;
    16..|      if Value &lt; 251 -&gt; &lt;&lt;Value&gt;&gt;;
     1..|         Value =&lt; 16#ffff -&gt; &lt;&lt;16#fc, Value:16/little&gt;&gt;;
     1..|         Value =&lt; 16#ffffff -&gt; &lt;&lt;16#fd, Value:24/little&gt;&gt;;
     1..|         Value =&lt; 16#ffffffffffffffff -&gt; &lt;&lt;16#fe, Value:64/little&gt;&gt;
        |      end.
        |  
        |  %% lenenc_str/1 decodes length-encoded-string values
        |  -spec lenenc_str(Input :: binary()) -&gt; {String :: binary(), Rest :: binary()}.
        |  lenenc_str(Bin) -&gt;
  1866..|      {Length, Rest} = lenenc_int(Bin),
  1866..|      &lt;&lt;String:Length/binary, Rest1/binary&gt;&gt; = Rest,
  1866..|      {String, Rest1}.
        |  
        |  %% nts/1 decodes a nul-terminated string
        |  -spec nulterm_str(Input :: binary()) -&gt; {String :: binary(), Rest :: binary()}.
        |  nulterm_str(Bin) -&gt;
    22..|      [String, Rest] = binary:split(Bin, &lt;&lt;0&gt;&gt;),
    22..|      {String, Rest}.
        |  
        |  -ifdef(TEST).
        |  -include_lib("eunit/include/eunit.hrl").
        |  
        |  %% Testing some of the internal functions, mostly the cases we don't cover in
        |  %% other tests.
        |  
        |  decode_text_test() -&gt;
        |      %% Int types
     1..|      lists:foreach(fun (T) -&gt;
     6..|                        ?assertEqual(1, decode_text(#col{type = T}, &lt;&lt;"1"&gt;&gt;))
        |                    end,
        |                    [?TYPE_TINY, ?TYPE_SHORT, ?TYPE_LONG, ?TYPE_LONGLONG,
        |                     ?TYPE_INT24, ?TYPE_YEAR]),
        |  
        |      %% BIT
     1..|      &lt;&lt;217&gt;&gt; = decode_text(#col{type = ?TYPE_BIT, length = 8}, &lt;&lt;217&gt;&gt;),
        |  
        |      %% Floating point and decimal numbers
     1..|      lists:foreach(fun (T) -&gt;
     2..|                        ?assertEqual(3.0, decode_text(#col{type = T}, &lt;&lt;"3.0"&gt;&gt;))
        |                    end,
        |                    [?TYPE_FLOAT, ?TYPE_DOUBLE]),
        |      %% Decimal types
     1..|      lists:foreach(fun (T) -&gt;
     2..|                        ColDef = #col{type = T, decimals = 1, length = 4},
     2..|                        ?assertMatch(3.0, decode_text(ColDef, &lt;&lt;"3.0"&gt;&gt;))
        |                    end,
        |                    [?TYPE_DECIMAL, ?TYPE_NEWDECIMAL]),
     1..|      ?assertEqual(3.0,  decode_text(#col{type = ?TYPE_FLOAT}, &lt;&lt;"3"&gt;&gt;)),
     1..|      ?assertEqual(30.0, decode_text(#col{type = ?TYPE_FLOAT}, &lt;&lt;"3e1"&gt;&gt;)),
     1..|      ?assertEqual(3,    decode_text(#col{type = ?TYPE_LONG}, &lt;&lt;"3"&gt;&gt;)),
        |  
        |      %% Date and time
     1..|      ?assertEqual({2014, 11, 01},
     1..|                   decode_text(#col{type = ?TYPE_DATE}, &lt;&lt;"2014-11-01"&gt;&gt;)),
     1..|      ?assertEqual({0, {23, 59, 01}},
     1..|                   decode_text(#col{type = ?TYPE_TIME}, &lt;&lt;"23:59:01"&gt;&gt;)),
     1..|      ?assertEqual({{2014, 11, 01}, {23, 59, 01}},
        |                   decode_text(#col{type = ?TYPE_DATETIME},
     1..|                               &lt;&lt;"2014-11-01 23:59:01"&gt;&gt;)),
     1..|      ?assertEqual({{2014, 11, 01}, {23, 59, 01}},
        |                   decode_text(#col{type = ?TYPE_TIMESTAMP},
     1..|                               &lt;&lt;"2014-11-01 23:59:01"&gt;&gt;)),
        |  
        |      %% Strings and blobs
     1..|      lists:foreach(fun (T) -&gt;
     9..|                        ColDef = #col{type = T},
     9..|                        ?assertEqual(&lt;&lt;"x"&gt;&gt;, decode_text(ColDef, &lt;&lt;"x"&gt;&gt;))
        |                    end,
        |                    [?TYPE_VARCHAR, ?TYPE_ENUM, ?TYPE_TINY_BLOB,
        |                     ?TYPE_MEDIUM_BLOB, ?TYPE_LONG_BLOB, ?TYPE_BLOB,
        |                     ?TYPE_VAR_STRING, ?TYPE_STRING, ?TYPE_GEOMETRY]),
     1..|      ok.
        |  
        |  decode_binary_test() -&gt;
        |      %% Test the special rounding we apply to (single precision) floats.
     1..|      ?assertEqual({1.0, &lt;&lt;&gt;&gt;},
        |                   decode_binary(#col{type = ?TYPE_FLOAT},
     1..|                                 &lt;&lt;1.0:32/float-little&gt;&gt;)),
     1..|      ?assertEqual({0.2, &lt;&lt;&gt;&gt;},
        |                   decode_binary(#col{type = ?TYPE_FLOAT},
     1..|                                 &lt;&lt;0.2:32/float-little&gt;&gt;)),
     1..|      ?assertEqual({-33.3333, &lt;&lt;&gt;&gt;},
        |                   decode_binary(#col{type = ?TYPE_FLOAT},
     1..|                                 &lt;&lt;-33.333333:32/float-little&gt;&gt;)),
     1..|      ?assertEqual({0.000123457, &lt;&lt;&gt;&gt;},
        |                   decode_binary(#col{type = ?TYPE_FLOAT},
     1..|                                 &lt;&lt;0.00012345678:32/float-little&gt;&gt;)),
     1..|      ?assertEqual({1234.57, &lt;&lt;&gt;&gt;},
        |                   decode_binary(#col{type = ?TYPE_FLOAT},
     1..|                                 &lt;&lt;1234.56789:32/float-little&gt;&gt;)),
     1..|      ok.
        |  
        |  null_bitmap_test() -&gt;
     1..|      ?assertEqual({&lt;&lt;0, 1:1&gt;&gt;, &lt;&lt;&gt;&gt;}, null_bitmap_decode(9, &lt;&lt;0, 4&gt;&gt;, 2)),
     1..|      ?assertEqual(&lt;&lt;0, 4&gt;&gt;, null_bitmap_encode(&lt;&lt;0, 1:1&gt;&gt;, 2)),
     1..|      ok.
        |  
        |  lenenc_int_test() -&gt;
        |      %% decode
     1..|      ?assertEqual({40, &lt;&lt;&gt;&gt;}, lenenc_int(&lt;&lt;40&gt;&gt;)),
     1..|      ?assertEqual({16#ff, &lt;&lt;&gt;&gt;}, lenenc_int(&lt;&lt;16#fc, 255, 0&gt;&gt;)),
     1..|      ?assertEqual({16#33aaff, &lt;&lt;&gt;&gt;}, lenenc_int(&lt;&lt;16#fd, 16#ff, 16#aa, 16#33&gt;&gt;)),
     1..|      ?assertEqual({16#12345678, &lt;&lt;&gt;&gt;}, lenenc_int(&lt;&lt;16#fe, 16#78, 16#56, 16#34,
     1..|                                                   16#12, 0, 0, 0, 0&gt;&gt;)),
        |      %% encode
     1..|      ?assertEqual(&lt;&lt;40&gt;&gt;, lenenc_int_encode(40)),
     1..|      ?assertEqual(&lt;&lt;16#fc, 255, 0&gt;&gt;, lenenc_int_encode(255)),
     1..|      ?assertEqual(&lt;&lt;16#fd, 16#ff, 16#aa, 16#33&gt;&gt;,
     1..|                   lenenc_int_encode(16#33aaff)),
     1..|      ?assertEqual(&lt;&lt;16#fe, 16#78, 16#56, 16#34, 16#12, 0, 0, 0, 0&gt;&gt;,
     1..|                   lenenc_int_encode(16#12345678)),
     1..|      ok.
        |  
        |  lenenc_str_test() -&gt;
     1..|      ?assertEqual({&lt;&lt;"Foo"&gt;&gt;, &lt;&lt;"bar"&gt;&gt;}, lenenc_str(&lt;&lt;3, "Foobar"&gt;&gt;)).
        |  
        |  nulterm_test() -&gt;
     1..|      ?assertEqual({&lt;&lt;"Foo"&gt;&gt;, &lt;&lt;"bar"&gt;&gt;}, nulterm_str(&lt;&lt;"Foo", 0, "bar"&gt;&gt;)).
        |  
        |  parse_header_test() -&gt;
        |      %% Example from "MySQL Internals", revision 307, section 14.1.3.3 EOF_Packet
     1..|      Packet = &lt;&lt;16#05, 16#00, 16#00, 16#05, 16#fe, 16#00, 16#00, 16#02, 16#00&gt;&gt;,
     1..|      &lt;&lt;Header:4/binary-unit:8, Body/binary&gt;&gt; = Packet,
        |      %% Check header contents and body length
     1..|      ?assertEqual({size(Body), 5, false}, parse_packet_header(Header)),
     1..|      ok.
        |  
        |  add_packet_headers_test() -&gt;
     1..|      {Data, 43} = add_packet_headers(&lt;&lt;"foo"&gt;&gt;, 42),
     1..|      ?assertEqual(&lt;&lt;3, 0, 0, 42, "foo"&gt;&gt;, list_to_binary(Data)).
        |  
        |  add_packet_headers_equal_to_0xffffff_test() -&gt;
     1..|      BigBin = binary:copy(&lt;&lt;1&gt;&gt;, 16#ffffff),
     1..|      {Data, 44} = add_packet_headers(BigBin, 42),
     1..|      ?assertEqual(&lt;&lt;16#ff, 16#ff, 16#ff, 42, BigBin/binary,
     1..|                     0,     0,     0,     43&gt;&gt;,
     1..|                   list_to_binary(Data)).
        |  
        |  add_packet_headers_greater_than_0xffffff_test() -&gt;
     1..|      BigBin = binary:copy(&lt;&lt;1&gt;&gt;, 16#ffffff),
     1..|      {Data, 44} = add_packet_headers(&lt;&lt;BigBin/binary, "foo"&gt;&gt;, 42),
     1..|      ?assertEqual(&lt;&lt;16#ff, 16#ff, 16#ff, 42, BigBin/binary, 3, 0, 0, 43, "foo"&gt;&gt;,
     1..|                   list_to_binary(Data)).
        |  
        |  add_packet_headers_2_times_greater_than_0xffffff_test() -&gt;
     1..|      BigBin = binary:copy(&lt;&lt;1&gt;&gt;, 16#ffffff),
     1..|      {Data, 45} = add_packet_headers(&lt;&lt;BigBin/binary, BigBin/binary, "foo"&gt;&gt;, 42),
     1..|      ?assertEqual(&lt;&lt;16#ff, 16#ff, 16#ff, 42, BigBin/binary,
        |                     16#ff, 16#ff, 16#ff, 43, BigBin/binary,
     1..|                     3,     0,     0,     44, "foo"&gt;&gt;,
     1..|                   list_to_binary(Data)).
        |  
        |  parse_ok_test() -&gt;
     1..|      Body = &lt;&lt;0, 5, 1, 2, 0, 0, 0, "Foo"&gt;&gt;,
     1..|      ?assertEqual(#ok{affected_rows = 5,
        |                       insert_id = 1,
        |                       status = ?SERVER_STATUS_AUTOCOMMIT,
        |                       warning_count = 0,
     1..|                       msg = &lt;&lt;"Foo"&gt;&gt;},
     1..|                   parse_ok_packet(Body)).
        |  
        |  parse_error_test() -&gt;
        |      %% Protocol 4.1
     1..|      Body = &lt;&lt;255, 42, 0, "#", "XYZxx", "Foo"&gt;&gt;,
     1..|      ?assertEqual(#error{code = 42, state = &lt;&lt;"XYZxx"&gt;&gt;, msg = &lt;&lt;"Foo"&gt;&gt;},
     1..|                   parse_error_packet(Body)),
     1..|      ok.
        |  
        |  parse_eof_test() -&gt;
        |      %% Example from "MySQL Internals", revision 307, section 14.1.3.3 EOF_Packet
     1..|      Packet = &lt;&lt;16#05, 16#00, 16#00, 16#05, 16#fe, 16#00, 16#00, 16#02, 16#00&gt;&gt;,
     1..|      &lt;&lt;_Header:4/binary-unit:8, Body/binary&gt;&gt; = Packet,
        |      %% Ignore header. Parse body as an eof_packet.
     1..|      ?assertEqual(#eof{warning_count = 0,
     1..|                        status = ?SERVER_STATUS_AUTOCOMMIT},
     1..|                   parse_eof_packet(Body)),
     1..|      ok.
        |  
        |  hash_password_test() -&gt;
     1..|      ?assertEqual(&lt;&lt;222,207,222,139,41,181,202,13,191,241,
     1..|                     234,234,73,127,244,101,205,3,28,251&gt;&gt;,
     1..|                   hash_password(&lt;&lt;"foo"&gt;&gt;, &lt;&lt;"abcdefghijklmnopqrst"&gt;&gt;)),
     1..|      ?assertEqual(&lt;&lt;&gt;&gt;, hash_password(&lt;&lt;&gt;&gt;, &lt;&lt;"abcdefghijklmnopqrst"&gt;&gt;)).
        |  
        |  -endif.
</pre>
</body>
</html>
